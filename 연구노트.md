## Intro

**skill: Eclipse + Spring Framework(+Boot) + Maven(=Build Tool) + MyBatis + MySQL(+H2) + 리팩토링{message + Validation + Exception}**

<br><br>

## 20250316~0410 - init project-boot ~ end

**이 프로젝트는 순수 스프링방식과 부트방식 둘 다 사용했다. (부트가 메인이긴 한데, XML 빈과 webapp구조를 감미한..)**

**[공식 홈페이지](https://www.egovframe.go.kr/home/sub.do?menuNo=94)의 eGovFframeDev-4.2.0 사용 -> Eclipse 2022-12 (4.26.0) 사용 및 JDK17 로 구동 (한글 깨지면 UTF-8 인코딩 체크)**

**퍼스펙티브 -> eGov 환경 필수**  
**이클립스 초기 환경설정 -> 글자크기, 힙메모리보기, 자동완성기능, 한글깨지면 UTF-8인코딩 등**

**eGovFrame -> stater -> boot web 플젝 생성 -> main함수 생성한 후 실행 테스트**  
참고: 순수스프링은 web.xml에 필터, 디스패처 서블릿 다 세팅한 덕분에 main함수 직접 작성 안해도 톰캣 위에서 동작  

> **ContextLoaderListener**는 **web.xml** 파일에 설정되어, 웹 애플리케이션이 시작될 때 **Spring** 애플리케이션 **컨텍스트를 초기화**
>
> 이 리스너는 **contextConfigLocation** 파라미터를 통해 **XML** 파일의 위치를 지정받고, 해당 파일을 로드하여 빈을 등록
>
> 이를 담당해주는 web.xml이 없으면 당연히 "자바코드"로 직접 작성해서 main함수로 실행해줘야 함.  
> ApplicationContext(스프링 컨테이너)를 초기화 하면 되고, 빈도 사용할 수 있다.  
> => XML 방식: ApplicationContext context = new ClassPathXmlApplicationContext("application.xml");  
> => Java Config 방식: ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);  
> AppConfig 클래스에 @Configuration 필수

**JSP 사용하게 Setting:**

- pom.xml:
  - jar 도 가능: 어차피 boot-starter의 내장톰캣으로 실행 됨.  
    - 나중에 외부 톰캣 쓰고 싶으면?   
      war변경+starter의존성provided+web.xml 구성 or SpringBootServletInitializer를 오버라이드(main함수 대신)
  - JSP 용 톰캣인 tomcat-embed-jasper 의존성 추가 및 타임리프 의존성은 주석
- WEB-INF 하위에 index.jsp 만들고, application.properties 세팅
  - spring.mvc.view.prefix=/WEB-INF/  
    spring.mvc.view.suffix=.jsp

**Boot에서 정적 파일(js,css,images 등) 사용하게 Setting:**

- 기존 순수 스프링(WAR)는 src/main/webapp하위 사용이 표준 구조.   
  그러나, Boot는 src/resources, static, templates 등이 표준 구조. 
  - 뷰는 templates보는게 기본값이라서 위에서 webapp/WEB-INF 하위 jsp를 사용하게 뷰를 설정했었다.
- 따라서 Boot 사용할거면 본인은 정적파일을 src/resources/static 하위에 두기로!

<br>

개발하면서 라이브러리에 **Egov꺼 보이면 우선**으로 사용하자!

**MVC2 개발: 자세한 개발 코드는 eGov플젝 참고**

> MyBatis만 사용할거면 JPA 어노테이션(ex:@OneToMany) 사용할 필요 없음. SQL 매퍼(xml)에서 해야함.  
>=> JPA는 엔티티 개념을 사용했지만, MyBatis는 직접SQL이라 DB개념으로 좀 더 생각하자.  
> 
> 즉, JPA의 영속성 컨텍스트로 도메인 패턴 필요 없음.   
>update도 더티체킹 없이 전부 SQL로 처리 해야 함.
> 
>PK값 자동증가 ID도 SQL 매퍼에서 MySQL은 useGeneratedKeys로 적용(auto_increment)  
> => [Mybatis 키 자동 생성 - useGeneratedKeys(MySQL), selectKey(Oracle)](https://sesoc.tistory.com/41)
>
> N+1 문제는 JPA-"페치조인(즉시로딩)+컬렉션은 distinct까지" 로 해결  
>MyBatis는 SQL문 사용하므로 조인이나 서브쿼리 덕분에 직면할 문제가 아님
> 
> update는 JPA에선 더티체킹 방식이지만, SQL인 MyBatis는 아님.  
> @Transactional에서 JPA는 영속성컨텍스트 덕분에 쿼리모아서 한번에 전송지만, MyBatis는 매순간 전송

1. **vo**

   > 예전엔 "자바끼리 통신"을 위해 엔티티(객체)에 직렬화 Serializable 인터페이스 구현 필수지만,   
   > 현재는 Json(+xml,csv등) 직렬화를 많이 사용하다 보니 Jackson 사용 시 필요가 없다.  
   > (Spring은 자동으로 이 직렬화를 제공 -> 예: @RestController)
   >
   > Serializable 참고 문법: 
   >
   > - Serializable 에서 PW 필드같은건 보안상 static이나 tansient키워드로 직렬화를 피할 수 있다.    
   > - serialVersionUID 는 명시해야 역직렬화할 때 클래스가 같음을 확인 가능

   PK값 자동증가 ID의 경우 eGov-GenId껀 @Deprecated니까 사용하지 말고,  
   MySQL이니 MyBatis의 useGeneratedKeys(=auto_increment) 쓰자.   
   JPA라면 @GeneratedValue(strategy = GenerationType.IDENTITY) 가 auto_increment 역할!

   JPA 사용 안하더라도 boot-jpa-data 의존성으로 "테스트DB + 자동 테이블생성"을 활용한다면,   
   @Entity+@Id+@GeneratedValue 선언은 필수! (JPA한테 알려주는것) -> 자세한건 test case 작성파트를 참고

   JPA의 더티체킹을 위한 엔티티에 update로직이나 연관메서드 등 MyBatis에선 사용할 필요가 없어짐.

2. **service(+dao) & Mybatis(얘가 뭐.. 레포역할이지!)**   
   @Repository, @Service로 구분 -> @Mapper 방식 사용 시 레포로 봐도 될 듯.  
   EgovAbstractMapper, EgovAbstractServiceImpl 상속 필수(단, @Mapper 사용 시 첫번째꺼 생략가능)

   생성자 빈 주입방식 사용! -> @RequiredArgsConstructor + final  
   DBIO로 쿼리 작성도 좋음.  
   인터페이스에 주석 넣어서 구현할 때 무슨 메소드인지 보기좋게 하자. (서비스 인터페이스에 했음)

   (mybatis 1)MyBatis 인터페이스 방식 구현(=@Mapper 방식): ItemService 인터페이스 + ItemServiceImpl 클래스(@Service로 자동 빈) + ItemMapper 인터페이스(@Mapper로 프록시로 자동 빈)  
   => 특히, ItemServiceImpl 클래스 = EgovAbstractServiceImpl 상속 + ItemService 구현체 역할

   (mybatis 2)xml설정부분: Mybatis-boot-starter 의존성 없으면(=순수스프링ver) context-mybatis.xml 필수(=빈 등록: SqlSessionFactoryBean:sql-mybatis-config.xml등록, MapperConfigurer:@Mapper 인터페이스 자동 스캔 위치 지정) +  
   sql-mybatis-config.xml 에서 \<mapper Item.xml> + lazy설정, 별칭, 캐시 등 ㄱㄱ +  
   Item.xml 에는 SQL문 작성!  

   (mybatis3)xml 사용 위해 main함수위에 `@ImportResource("classpath:/spring/*.xml")` 로 등록   
   참고) context-common.xml 도 추가했음. (eGov서비스에 leaveaTrace빈 때매) 

   **자세한 사용과 문법은 "DB필독 MyBatis 파트" 참고**
   
   <details><summary><b>전체코드와 사용 파일 한눈에 보기</b></summary>
   <div markdown="1"><br>
   {src/main/resources/}spring/context-mybatis.xml -> sqlSession빈<br>
   {src/main/resources/}sqlmap/sql-mybatis-config.xml -> Item.xml(매퍼)연결 및 별칭,캐시 등<br> 
   {src/main/resources/}sqlmap/mappers/Item.xml -> SQL<br>
   {src/main/java/}...service.impl/ItemMapper.java -> @Mapper<br>
   {src/main/java/}...service.impl/ItemServiceImpl.java -> @Service<br>
   {src/main/java/}...service/ItemService.java -> (그냥 확장성 위해 인터페이스 추가한거일 뿐)<br>
   **context-mybatis.xml**
   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
   	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd">
   	<!-- 애초에 boot-mybatis-starter 라이브러리 사용했으면 이부분 자동 설정해 줌. 안 사용해서 추가한거임. -->
   <!-- -->
   	<!-- SqlSession setup for MyBatis Database Layer -->
   	<!-- MyBatis와 Spring 연동 설정
   	물론, 스프링부트는 java 파일에서 빈 등록을 권장 -->
   	<bean id="sqlSession"
   		class="org.mybatis.spring.SqlSessionFactoryBean">
   		<property name="dataSource" ref="dataSource" />
   		<property name="configLocation"
   			value="classpath:/sqlmap/sql-mybatis-config.xml" />
   		<!-- <property name="mapperLocations" value="classpath:**/lab-*.xml" /> -->
   	</bean>
   	<!-- MapperConfigurer setup for @Mapper -->
   	<!-- MyBatis의 Mapper Interface 자동스캔 설정 
   	물론, 스프링부트는 java 파일에서 빈 등록을 권장 -->
   	<bean class="org.egovframe.rte.psl.dataaccess.mapper.MapperConfigurer ">
   		<property name="basePackage"
   			value="com.secretgallery.service.impl" />
   	</bean>
   </beans>	
   ```
   **sql-mybatis-config.xml**
   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
   <configuration>
   <!--  -->
   	<settings>
   		<setting name="cacheEnabled" value="true" />
   		<setting name="lazyLoadingEnabled" value="true" />
   		<setting name="multipleResultSetsEnabled" value="true" />
   		<setting name="mapUnderscoreToCamelCase" value="true" />
   	</settings>
   	<!-- 별칭 지정시 sql문쪽 resultType 이런곳에서 "클래스명"만으로 바로 사용 가능! 
   	단, 클래스단위임. 패키지 단위는 application.properties에서 해야함. -->
   	<typeAliases>
   		<typeAlias alias="Item"
   			type="com.secretgallery.vo.Item" />
   	</typeAliases>
   <!--  -->
   	<typeHandlers>
   		<typeHandler
   			handler="org.egovframe.rte.psl.dataaccess.typehandler.CalendarMapperTypeHandler" />
   	</typeHandlers>
   <!--  -->
   	<mappers>
   		<mapper resource="sqlmap/mappers/Item.xml" />
   	</mappers>
   </configuration>
   ```
   **Item.xml**
   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
   <mapper namespace="com.secretgallery.service.impl.ItemMapper">
   	<insert id="save" useGeneratedKeys="true" keyProperty="id">
   		insert
   		into item (nickname, password, title, content, img_src, date1, date2)
   		values (#{nickname}, #{password}, #{title}, #{content}, #{imgSrc},
   		#{date1}, #{date2})
   	</insert>
   	<update id="update">
   		update item
   		set password=#{password},
   		title=#{title},
   		content=#{content}
   		where item_id = #{id}
   	</update>
   	<select id="findById" resultType="Item">
   		select item_id as id, nickname,
   		password, title, content, img_src, date1,
   		date2
   		from item
   		where item_id =
   		#{id}
   	</select>
   	<delete id="delete">
   		delete from item where item_id = #{id}
   	</delete>
   	<select id="findAll" resultType="Item">
   		select item_id as id, nickname,
   		password, title, content, img_src,
   		date1,
   		date2
   		from item
   	</select>
   <!--  -->
   	<!-- DBIO 써보기 + as별칭 말고 resultMap 써보기 -->
   	<resultMap id="item" type="Item">
   		<result property="id" column="item_id" />
   		<result property="nickname" column="nickname" />
   		<result property="password" column="password" />
   		<result property="title" column="title" />
   		<result property="content" column="content" />
   		<result property="imgSrc" column="img_src" />
   		<result property="date1" column="date1" />
   		<result column="date2" property="date2" />
   	</resultMap>
   	<!-- (동적쿼리)검색+페이징 -->
   	<select id="findAllWithPage" resultMap="item">
   		SELECT *
   		FROM item
   		<where>
   			<if test="searchKeyword != null and searchKeyword != ''">
   				<choose>
   					<when test="searchCondition == 0">
   						and id like concat('%', #{searchKeyword}, '%')
   					</when>
   					<when test="searchCondition == 1">
   						and title like concat('%', #{searchKeyword}, '%')
   					</when>
   				</choose>
   			</if>
   		</where>
   		order by item_id DESC 
   		LIMIT #{recordCountPerPage} OFFSET #{firstIndex}
   	</select>
   	<select id="findTotalCount" resultType="int">
   		SELECT count(*) FROM Item
   		<where>
   			<if test="searchKeyword != null and searchKeyword != ''">
   				<choose>
   					<when test="searchCondition == 0">
   						and id like concat('%', #{searchKeyword}, '%')
   					</when>
   					<when test="searchCondition == 1">
   						and title like concat('%', #{searchKeyword}, '%')
   					</when>
   				</choose>
   			</if>
   		</where>
   	</select>
   	<!-- 자동검색(ajax) -->
   	<select id="findTitleListForSuggest" resultType="string">
   		SELECT TITLE
   		FROM item
   		where title like '%' || #{value} || '%'
   		<!-- where title like concat('%', #{value}, '%') -->
   	</select>
   	<select id="findPrevNextById" resultMap="item">
   		<![CDATA[
   		SELECT * FROM Item WHERE
   		item_id >= #{prevId} and item_id <= #{nextId}
   		]]>
   	</select>
   </mapper>
   ```
   **ItemMapper.java**
   ```java
   //Mapper Interface - 메서드명과 쿼리ID를 매핑하여 쿼리호출
   @Mapper
   public interface ItemMapper {
   	public Long save(Item item);
   	public Long update(Item item);
   	public Long delete(Item item);
   	public Item findById(Long id);
   	public List<Item> findAll();
   //	
   	public List<Item> findAllWithPage(ItemDefault searchItem);
   	public int findTotalCount(ItemDefault searchItem);
   	public List<String> findTitleListForSuggest(String value);
   	public List<Item> findPrevNextById(@Param("prevId") Long prevId, @Param("nextId") Long nextId);
   }
   ```
   **ItemServiceImpl.java**
   ```java
   @Service
   @Transactional(readOnly = true) 
   @RequiredArgsConstructor
   @Slf4j
   public class ItemServiceImpl extends EgovAbstractServiceImpl implements ItemService {
   	private final ItemMapper itemMapper;
   	//CRUD
   	@Override
   	@Transactional // 쓰기모드
   	public Long save(Item item) throws Exception {
   		return itemMapper.save(item);
   	}
   	@Override
   	@Transactional // 쓰기모드
   	public Long update(Item item) throws Exception {
   		// TODO Auto-generated method stub
   		return itemMapper.update(item);
   	}
   	@Override
   	@Transactional // 쓰기모드
   	public Long delete(Item item) throws Exception {
   		// TODO Auto-generated method stub
   		return itemMapper.delete(item);
   	}
   	@Override
   	public Item findById(Long id) throws Exception {
   		return itemMapper.findById(id);
   	}
   	@Override
   	public List<Item> findAll() throws Exception {
   		// TODO Auto-generated method stub
   		return itemMapper.findAll();
   	}
   //
   	//추가 함수
   	@Override
   	public List<Item> findAllWithPage(ItemDefault searchItem) throws Exception {
   		// TODO Auto-generated method stub
   		return itemMapper.findAllWithPage(searchItem);
   	}
   	@Override
   	public int findTotalCount(ItemDefault searchItem) throws Exception {
   		// TODO Auto-generated method stub
   		return itemMapper.findTotalCount(searchItem);
   	}
   	@Override
   	public List<String> findTitleListForSuggest(String value) throws Exception {
   		// TODO Auto-generated method stub
   		return itemMapper.findTitleListForSuggest(value);
   	}
   	@Override
   	public List<Item> findPrevNextById(Long id) throws Exception {
   		// TODO Auto-generated method stub
   		return itemMapper.findPrevNextById(id-1, id+1);
   	}
   }
   ```
   **ItemService.java**
   ```java
   /**
    * CRUD + 
    * findAllWithPage + findTotalCount + findTitleListForSuggest + findPrevNextById
    	* 총 게시물 수 구하는 함수: findTotalCount()
    	* 이전, 이후 전시실 버튼 생성용: findPrevNextById()
    	* 검색 자동완성 함수: findTitleListForSuggest()
    */
   public interface ItemService {
   	/**
   	 * CRUD - C
   	 * @param item
   	 * @return count(개수)
   	 * @throws Exception
   	 */
   	public Long save(Item item) throws Exception;
   	/**
   	 * CRUD - U
   	 * @param item
   	 * @return count(개수)
   	 * @throws Exception
   	 */
   	public Long update(Item item) throws Exception;
   	/**
   	 * CRUD - D
   	 * @param item
   	 * @return count(개수)
   	 * @throws Exception
   	 */
   	public Long delete(Item item) throws Exception;
   	/**
   	 * CRUD - R
   	 * @param id
   	 * @return 
   	 * @throws Exception
   	 */
   	public Item findById(Long id) throws Exception;
   	/**
   	 * CRUD - R
   	 * @return 
   	 * @throws Exception
   	 */
   	public List<Item> findAll() throws Exception;
   	//
   	//추가 함수
   	/**
   	 * 해당 페이지 Item 전부 조회 by desc
   	 * @param pageId
   	 * @return
   	 * @throws Exception
   	 */
   	public List<Item> findAllWithPage(ItemDefault searchItem) throws Exception;
   	/**
   	 * 전체 Item의 총 개수
   	 * @return
   	 * @throws Exception
   	 */
   	public int findTotalCount(ItemDefault searchItem) throws Exception;
   	/**
   	 * 검색에 자동완성 기능
   	 * @param value
   	 * @return
   	 * @throws Exception
   	 */
   	public List<String> findTitleListForSuggest(String value) throws Exception;
   	/**
   	 * Item의 이전, 이후 Item 구하기
   	 * @param id
   	 * @return
   	 * @throws Exception
   	 */
   	public List<Item> findPrevNextById(Long id) throws Exception;
   }
   ```
   </div>
   </details>
   
3. **controller + JSP**  
   @Controller 및 @RequestMapping 로 Spring MVC 준수 필수!  
   => 어차피 @GetMapping, @PostMapping 와 사용법도 기능도 유사하다. 오히려 유지보수좋게 이걸로 ㄱ  
   => 클래스 단에는 @RequestMapping 유용하니 써줘도 좋고! (공통URL)  

   참고: 타임리프 플젝에서 좀 엉망인 "주석"을 eGov적용 웹 플젝에서 좀 다듬었다.
   
   반환타입 void일 때: 자동으로 뷰리졸버는 요청URL과 동일한 뷰를 탐색해서 반환! (직접 String반환 안해도!)
   
   @RequestParam, @PathVariable, @ModelAttributes 헷갈릴 때: [쳌리-컨트롤러](https://bh946.github.io/checklist/CHECK_LIST_SPRING/#%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8%EC%9D%98-%EC%95%A0%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98%EB%93%A4) **ㅎㅋㅎㅋ 여기도 다 타****임리프에서 정리했고, JSP는 JSP만 ㄱㄱㄹ** 
   ⇒ Model은 MVC의 M부분이다.  
   결론: @ModelAttributes는 자세한 기능을 알고 사용하자. 웬만하면 GET엔 @RequestParam이나 @PathVariable(권장!) 쓰자.  
   @ModelAttributes의 자세한 동작은 Model로 addAttribute하는걸 자동화 함.  
   => (예: 넘어온 데이터가 없다면 빈 객체를 자동으로 Model에 담거나, @ModelAttributes("item") ItemDto dto이면 form 데이터를 자동으로 ItemDto에 매핑 및 Model엔 item이름으로 기록한다.)  
   주의: form으로 넘길 때는 선언한 name(id)필드는 꼭 매핑이 다 되어야함. ex: ...(@ModelAttribute UpdateItemDto dto) 라면 form의 필드들이 최소한 UpdateItemDto에 전부 있어야 함
   
   return "jsp/gallery", {return "redirect:/gallery", return "forward:/gallery"}, return this.gallery(item, model) 헬갈릴 때: [쳌리-PRG패턴](https://bh946.github.io/checklist/CHECK_LIST_SPRING/#3-thymeleaf-tip---%ED%95%84%EB%8F%85)  
   결론: jsp반환은 "직접 뷰 반환", redirect&forward는 "HTTP URL로 매핑", 메소드는 "일반 메소드 생각"
   
   PRG 패턴 값 넘길 때 redirectAttributes를 주로 활용함. (메소드: addAttribute, addFlashAttribute)
   
   ```java
   //예시 코드
   redirectAttributes.addAttribute("itemId", itemId);
   redirectAttributes.addAttribute("test", test);
   redirectAttributes.addFlashAttribute("status", "updateOFF");
   return "redirect:/gallery/itemDetail/{itemId}"; // 기존 화면 다시 로딩
   ```
   
   - addAttribute는 자동으로 URL에 붙어서(쿼리 파라미터) 넘어간다.  
     - 예로 위 코드에선 itemId는 이미 URL에 있으니 test만 URL에 추가로 "?test=값" 형태로 넘어간다.
   - addFlashAttribute를 사용하면 1번만 값을 넘겨주고 자동으로 지워준다. 
     - PRG패턴으로 무한 POST를 피해도 클라에서 status값 보고 alert를 띄운다면, GET이여도 새로고침하면 클라 자체에서 계속 alert가 뜨는 불편함이 있는데 이를 피할 수 있는 유용한 기능이다.
     - 중요한점: JSP에서 `<body data-status="${status}">` 이렇게 해줘야 `document.body.getAttribute('data-status');` 로 상태값을 js에서 잘 활용할 수 있다.
   
   특히, JSP는 타임리프꺼 복붙하여 문법 JSP로 바꾸는게 전부.  
   예로: fragment -> jsp:include, th:src -> c:url, th:text -> spring:message, text -> c:out, th:each -> c:forEach,  th:if -> c:if, th:error -> form:error 등 코드는 아래 참고
   
   <details><summary><b>타임리프 -> JSP 예시: img, message, fragment, text, forEach, if, error</b></summary>
   <div markdown="1"><br>
   ```jsp
   <!-- img 예시 -->
   <img class="img-fluid" src="<c:url value='/images/gallery/6-2.svg'/>"
        style="width: 100%;"/>
   <!-- message 예시 -->
   <span class="px-3" style="font-size: 2vw; font-weight: 700; color: white; white-space: nowrap;">
       <spring:message code="page.gallery" text="전시실" />
   </span>
   <!-- fragment 예시 (param 도 가능) -->
   <jsp:include page="fragments/header.jsp"/>
   <jsp:include page="fragments/head.jsp">
       <jsp:param value="갤러리" name="title" />
   </jsp:include>
   <!-- text 예시 (c:out, fmt: 등 다양함) -->
   <span class="nav-item-inner">B1 ~ B<fmt:formatNumber value="${paginationInfo.getTotalRecordCount() / paginationInfo.getRecordCountPerPage()}" pattern="#" />F
   </span>
   <span style="font-weight: 500; color: white; font-size: 1.4vw;">B
       <c:out value='${paginationInfo.getCurrentPageNo()}'/>F
   </span>
   <!-- text 번외: fmt는 Date만 지원, LocalDate는?? -->
   <%@ page import="java.time.format.DateTimeFormatter" %>
   ${itemResDto.date1.format(DateTimeFormatter.ofPattern('yy.MM.dd.HH:mm'))}
   <!-- forEach 예시 (반복문) -->
   <c:forEach items="${itemsResDto}" var="itemResDto" varStatus="status">
       ...
   </c:forEach>
   <!-- if 예시 Java or JSP-->
   <%
   if (item != null && item.getImgSrc() != null) {
   %>
       <img src="<%= item.getImgSrc() %>" alt="이미지">
   <%
   }
   %>
   <c:if test="${item != null && item.imgSrc != null}">
       <img src="${item.imgSrc}" alt="이미지">
   </c:if>
   <!-- error 예시: th:error처럼 form:error로 표현 가능 -->
   <!-- th:error, form:error 둘다 bindingResult의 검증결과를 활용하여 메시지 출력 -->
   <!-- 자세한건 뒤에 검증 파트를 보는걸 추천 --> 
   <!-- 아래 코드는 "직접 bindingResult 다루는 예시" -->
   컨트롤러에서 bindingResult를 model에 담아서 반환했다 가정:
   <div class="field-error">
       <c:if test="${not empty bindingResult.fieldErrors}">
           비밀번호 오류
           <%-- 비밀번호 오류: <c:out value="${bindingResult.fieldErrors['password']}" /> --%>
       </c:if>
   </div>
   ```
   </div>
   </details>
   
   "게시물 페이징, 자동완성(검색)"에 AJAX를 적용했다! (SPA 방식. BGM 사용중이면 끊길 걱정도 없어짐)  
   => 아래 eGov 방식의 "검색(동적쿼리)+페이징, 자동완성(검색)" 파트 참고
   
   **컨트롤러 로직에서 생각할 점: -> JPA에서 새로 정리해버림. 그거나 복붙ㄱㄱㄹ. -> JSP는 JSP만 정리하고 이쪽들 보라하긔.**
   
   1. DTO관련 생각: 굳이 필드 숨길게 없으면 안해도 되겠지만 password처럼 있으면 꼭 생성하자. 어차피 "요청DTO, 응답DTO" 둘 다 사용한다고 해서 코드만 조금 복잡해지지 성능이 떨어지고 할건 없다.  
      특히, 검증(ex:@Validation)도 따로 지정할 수 있어 더 효과적이다.
   
      "파일위치"는 컨트롤러면 controller/dto/*, 엔티티쪽 비즈니스 로직으로 인해 사용한다면 entity/dto/\* 이런식으로 가져가면 됨, 간단한건 static class로 코드내에 가져가도 됨.  
      => 즉, 자기가 사용하는 쪽 하위에 달아두기. (규칙은 아니고 난 이렇게 함)
      
      참고: 아래코드는 Bean validator 방식
      
      <details><summary><b>본인 판단하에 DTO 사용 & 사용안한 코드 예시:</b></summary>
      <div markdown="1"><br>
      **WEB) GalleryController -> gallery(), StudioController -> studioIdUpdate**
      ```java
      /**
      	 * 페이지 별로 조회 메서드 -> 페이징
      	 * 
      	 * @param item  -> 어차피 숨기고 싶은 password가 안들어 올거라서 요청은 DTO로 안 받겠다.
      	 * @param model -> 응답DTO 사용
      	 * @return
      	 * @throws Exception
      	 */
      	@GetMapping()
      	public String search(@ModelAttribute Item item, Model model) throws Exception {
      //		log.info("itemId: {}",item.getId());
      		return this.gallery(item, model); // HTTP말고 그냥 메소드 호출한거.(포워드,리다이렉트 아님)
      	}
      	@PostMapping() // ...?pageIndex=1 이런식으로 페이지 파라미터 넘어 올거임(pageIndex란 Item이 상속받고 있는 DefaultItem의
      					// 필드)
      	public String gallery(@ModelAttribute Item item, Model model) throws Exception {
      		item.setPageUnit(myDataSource.getPageUnit());
      		item.setPageSize(myDataSource.getPageSize());
      //
      		// pagination setting
      		PaginationInfo paginationInfo = new PaginationInfo();
      		paginationInfo.setCurrentPageNo(item.getPageIndex());
      		paginationInfo.setRecordCountPerPage(item.getPageUnit());
      		paginationInfo.setPageSize(item.getPageSize());
      //
      		item.setFirstIndex(paginationInfo.getFirstRecordIndex());
      		item.setLastIndex(paginationInfo.getLastRecordIndex());
      		item.setRecordCountPerPage(paginationInfo.getRecordCountPerPage());
      //
      		// List
      		List<Item> items = itemService.findAllWithPage(item);
      		List<ItemResDto> itemsResDto = items.stream().map(o -> new ItemResDto(o)).collect(Collectors.toList());
      		int totCnt = itemService.findTotalCount(item);
      //
      		model.addAttribute("itemsResDto", itemsResDto);
      		paginationInfo.setTotalRecordCount(totCnt);
      		// Pagination
      		model.addAttribute("paginationInfo", paginationInfo);
      		log.info("cnt: {}, resultList: {}", totCnt, items);
      //
      		return "jsp/gallery";
      	}
      //
      /**
           * 수정 데이터 작성 -> 정보 기입
           * 특징: 갤러리-아이템에서 이곳으로 접근
           * @param itemId
           * @param model
           * @return
           * @throws Exception 
           */
          @GetMapping("item/{itemId}")
          public String studioCompleteId(@PathVariable Long itemId, @RequestParam int pageIndex, Model model) throws Exception {
          	//pageIndex를 URL param으로 gallery -> gallery-item --modal--> studio-item 흐름
          	model.addAttribute("pageIndex", pageIndex);
              Item item = itemService.findById(itemId);
              model.addAttribute("item", item);
              return "/jsp/studio_item"; 
          }
      //
          /***
           * 수정 수행 -> 정보 기입
           * @param form -> 요청 DTO (Valid로 JSP에 출력)
           * @param bindingResult
           * @param itemId
           * @param redirectAttributes
           * @return
           * @throws Exception
           */
          @PostMapping("item/{itemId}")
          public String studioIdUpdate(@Validated @ModelAttribute UpdateItemDto form, @RequestParam int pageIndex, BindingResult bindingResult,
                                       @PathVariable Long itemId, RedirectAttributes redirectAttributes, Model model) throws Exception {
              if(bindingResult.hasErrors()) {
                  log.info("error={}", bindingResult);
                  model.addAttribute("bindingResult", bindingResult);
                  return "jsp/studio_item"; //다시 폼으로 이동
                  // 어차피 "검증" 에 걸려서 DB 사용안하기에 PRG 패턴 상관없움
              }
              log.info("title테스트={}", form.getTitle());
              form.setPageIndex(pageIndex);
              itemService.update(form);
            redirectAttributes.addFlashAttribute("status", "updateON");
            redirectAttributes.addAttribute("itemId", itemId);
            return "redirect:/gallery/itemDetail/{itemId}";
          }
      //Dto 클래스
      @Data
      public class UpdateItemDto {
      	  @NotNull
      	  private Long id;
      	  @NotNull
      	  private String nickname;
      	  @NotNull
      	  @Pattern(regexp = "^[0-9]+", message = "비밀번호는 숫자로 입력 해주세요.")
      	  private String password;
      	  @NotNull
      	  private String title;
      	  @NotNull
      	  private String content;
            private int pageIndex;
      }
      ```
      **API) ListsApiController -> findByDateWithMemberTask()**
      ```java
      /**
         * 일정 조회(4) - 날짜범위로 Lists(=하루단위 일정모음) 조회 -> 해당 회원꺼만 하루, 한달, 1년 등등 원하는 날짜 범위만큼 사용 가능
         * 요청Dto, 응답Dto
         * @param bindingResult -> 검증 결과로 API(JSON)으로 출력 목적
         */
        @PostMapping(value = "/member/date")
        public ResponseEntity<ApiResponse<List<ListsResDto>>> findByDateWithMemberTask(
            @Login Long memberId,
            @RequestBody @Validated CreateListsRequestDto request, BindingResult bindingResult) {
          if (bindingResult.hasErrors()) {
            log.info("검증 오류 발생 errors={}", bindingResult);
            ApiResponse res = ApiResponse.error(HttpStatus.BAD_REQUEST.value(), bindingResult);
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(res);
          }
          List<Lists> listsList = listsService.findByDateWithMemberTask(memberId, request.startTime,
              request.endTime);
          if (listsList.isEmpty()) {
            ApiResponse res = ApiResponse.success(HttpStatus.NO_CONTENT.value(), null);
            return ResponseEntity.status(HttpStatus.NO_CONTENT).body(res);
          }
          List<ListsResDto> result = listsList.stream()
              .map(o -> new ListsResDto(o))
              .collect(Collectors.toList());
          ApiResponse res = ApiResponse.success(HttpStatus.OK.value(), result);
          return ResponseEntity.status(HttpStatus.OK).body(res);
        }
      //
      // DTO
        @Getter
        static class ListsResDto {
          private Long listsId;
          private LocalDate listsDate; // 등록 날짜
          private String timerAllUseTime; // 타이머총사용시간
          private List<TaskDto> listsTasks;
          public ListsResDto(Lists lists) { // lazy 강제 초기화
            listsId = lists.getId();
            listsDate = lists.getListsDate();
            Long time = lists.getTimerAllUseTime();
            Long hour = time / (60 * 60 * 1000);
            time %= (60 * 60 * 1000);
            Long minute = time / (60 * 1000);
            time %= (60 * 1000);
            Long second = time / (1000);
            timerAllUseTime = hour + ":" + minute + ":" + second; // 시:분:초 형태로 반환
            listsTasks = lists.getTasks().stream()
                .map(o -> new TaskDto(o))
                .collect(Collectors.toList());
          }
        }
        @Getter
        static class CreateListsRequestDto {
          @NotNull(message = "날짜 범위는 필수입니다.")
          private LocalDateTime startTime;
          @NotNull(message = "날짜 범위는 필수입니다.")
          private LocalDateTime endTime;
        }
      ```
      </div>
      </details>
      
   2. 반환에 대한 생각: API는 JSON을 반환해서 반환처리가 "String+여러가지"로 복잡한 반면, 웹은 "String"만 해도 충분! (String으로 간단히 jsp 반환)
   
   3. 컨트롤러 에서의 JPA vs MyBatis 관점 POINT: "JSP에서 Item정보를 가져온다 가정"
   
      JPA에선 update나 delete할때 항상 findOne으로 해당 Item을 DB에서 찾아와서 "영속성 만들고" update, delete를 적용했다. (특히, "더티체킹" 사용하려면 영속성을 꼭 만들어야 한다.)   
      MyBatis에선 SQL직접 작성하니 findOne을 따로하지 않고 JSP에서 얻은 Item정보로 바로 update, delete 쿼리를 적용했다. (영속성 필요가 없으니)
   
      따라서 복잡한 도메인(객체) 중심은 JPA, 쿼리 최적화가 중요하면 MyBatis가 좋겠다.  
      JPA가 더티체킹위해 비즈니스 로직(update)이 엔티티단에 캡슐화 가능한 관점처럼 둘은 차이가 있다.
   
   4. API JSON직렬화 덕분에 유연 vs JSP(웹)는 엄격한 Bean규약: 예로 (private)static class vs public static class
   
      API 컨트롤러의 경우:
   
      - **주로 해당 컨트롤러 내에서만 DTO를 사용**
      - 응답 데이터는 JSON으로 직렬화되어 전송됨 
        - 이때 **Jackson**같은 라이브러리가 리플렉션 활용하여 private 접근 가능
      - **클라이언트 측에서는 이미 직렬화된 데이터를 받기 때문**에 Java 클래스의 접근성 제한에 영향을 받지 않음
      
      JSP의 경우:
      
      - **컨트롤러에서 사용할 뿐만 아니라 JSP 페이지에서도 직접 객체에 접근**
      - JSP 표준 액션 태그나 EL 표현식이 **Java 객체에 직접 접근**해야 함
      - 따라서 Bean 클래스와 그 멤버들이 public으로 선언되어야 함(**ex: 응답DTO가 public**)
   
4. **test case -> entity, repository, service, controller(=JSP로 바로 봤으니 얜 생략)**

   eGov4.2 순수 스프링은 jUnit4를 사용, 부트는 jUnit5를 사용. -> 문법 다른점 주의.  

   > jUnit4로 강제로 사용 당연히 설정하면 가능.

   우클릭>new>junit test case>파일이름 설정 + Browse에서 테스트할 클래스(com.secretgallery...) > 이후 테스트 코드 작성. (tdd로 자동완성했던 방식으로 ㄱㄱ)
   
   테스트를 위해 "메모리DB"를 사용하려는데 boot-jpa-data 의존성은 application.properties에 DB설정 없으면 메모리DB 자동 제공 및 테이블도 만들어 줌!   
   따라서 의존성을 추가 및 테이블에 @Entity, @Id, @GeneratedValue를 VO에서 붙였었음(본인은 이게편함)  
   => 가이드에선 테스트코드에 @Before에 hsqld의 쿼리문 호출하여 메모리DB에 table생성했다.  
   예: `ScriptUtils.executeSqlScript(dataSource.getConnection(), new ClassPathResource("META-INF/testdata/sample_schema_hsql.sql"));`

   <details><summary><b>MyBatis 테스트를 위해 꼭 참고할 점:</b></summary>
   <div markdown="1"><br>
   1. main/resources하위 XML수동 빈 등록은 test/resources 하위로 복제하자  
      (단, XML내 빈에 property로 연동한 XML은 복제 안해도 됨. 자동으로 main하위도 찾아줌.  
      예로 XML내 빈에 연동된 XML이 아닌 context-common.xml의 경우  `@ImportResource("classpath:/spring/*.xml")` 로 main함수위에 직접 등록해야하는데,  
      빈 내에서 XML연동한 파일의 경우 "test하위로 복제 안해도 main에서 찾아 주더라"  
      **=> 따라서 SQL을 작성한 XML은(=따로 빈에서 연동된) main에서만 관리하면 됨!**
      테스트를 위한 XML 관리법을 다시 정리하자면,   
      **부트니까 @SpringBootTest 를 사용하여 메인환경의 빈을 자동 등록(자동 빈, 수동 빈 둘다)  
      메인환경의 수동 빈 등록법은 "@ImportResource("classpath:..) 필수 + 테스트환경에 ImportResource로 등록한 XML 파일 복제"**
   2. boot-jpa-data 의존성으로 자동 테이블 생성 사용 시 "데이터 타입 매핑과 자동 언더스코어(db)에서 카멜케이스(java)"를 알자.  
      테이블 자동 생성 JPA: `Long` → `bigint`, `String` → `varchar(255)`, `LocalDateTime` → `datetime(6)`    
      `@Id+@GeneratedValue(strategy = GenerationType.IDENTITY)` → `PK+not null auto_increment`  
      **MyBatis에서 맞춰주자: XML에서 언더스코어에서 카멜케이스 자동 매핑 설정.   **
      **예: sql에 ${imgSrc} <- img_src 매핑**  
      **객체 매핑 주의점:** sql에 아예 필드명 다른건 select **item_id as id** .. where item_id = #{id} 이런식으로 하거나,  
      **Result Maps**을 사용 -> **as 별칭을 대체!**
   </div>
   </details>
   controller 테스트는 그냥 JSP로 보면서 개발했으니 생략하자. (API면 반드시 Mock하는게 좋을듯)
   
   <details><summary><b>서비스단 테스트코드 - 페이징 포함:</b></summary>
   <div markdown="1"><br>
   ```java
   package com.secretgallery.service.impl;
   import static org.assertj.core.api.Assertions.*;
   import java.util.List;
   import org.egovframe.rte.ptl.mvc.tags.ui.pagination.PaginationInfo;
   import org.junit.jupiter.api.Test;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.context.SpringBootTest;
   import org.springframework.transaction.annotation.Transactional;
   import com.secretgallery.vo.Item;
   import com.secretgallery.vo.ItemDefault;
   import com.secretgallery.vo.UpdateItemDto;
   import lombok.extern.slf4j.Slf4j;
   @SpringBootTest // @SpringBootApplication을 찾아서 테스트를 위한 Bean을 생성
   @Transactional // 쓰기모드 -> 서비스코드에 트랜잭션 유무 반드시 확인
   @Slf4j
   class ItemServiceImplTest {
   	@Autowired
   	private ItemServiceImpl itemService;
   	@Test
   	void 저장과조회() throws Exception {
   		// 테스트 데이터 준비
   		Item item = Item.createItem("테스트 닉네임", "비밀번호", "테스트 제목", "테스트 내용", "이미지 경로");
   		// 저장 후 ID 확인 -> 1,2 id
   		Long cnt = itemService.save(item);
   		log.info("itemId: {}", item.getId());
   		itemService.save(item);
   		log.info("itemId: {}", item.getId());
   		assertThat(cnt).isNotNull();
   		// 저장된 데이터 조회
   		Item findItem = itemService.findById(item.getId());
   		log.info("nickname: {}", findItem.getNickname());
   		assertThat(findItem.getNickname()).isEqualTo(item.getNickname());
   		assertThat(findItem.getTitle()).isEqualTo(item.getTitle());
   	}
   	@Test
   	public void 수정() throws Exception {
   		// given
   		Item item = Item.createItem("테스트 닉네임", "비밀번호", "테스트 제목", "테스트 내용", "이미지 경로");
   		itemService.save(item);
   		log.info("itemId: {}, title: {}", item.getId(), item.getTitle());
   		// when
   		UpdateItemDto updateItem = new UpdateItemDto();
   		updateItem.setId(item.getId());
   		updateItem.setNickname(item.getNickname());
   		updateItem.setPassword("비번");
   		updateItem.setTitle("제목");
   		updateItem.setContent("내용");
   		itemService.update(updateItem);
   		Item findItem = itemService.findById(item.getId());
   		// then
   		assertThat(findItem).isNotNull();
   		assertThat(findItem.getId()).isEqualTo(updateItem.getId());
   		assertThat(findItem.getTitle()).isEqualTo(updateItem.getTitle());
   		log.info("itemId: {}, title: {}", findItem.getId(), findItem.getTitle());
   	}
   	@Test
   	public void 삭제() throws Exception {
   		// given
   		Item item = Item.createItem("테스트 닉네임", "비밀번호", "테스트 제목", "테스트 내용", "이미지 경로");
   		itemService.save(item);
   		Long itemId = item.getId();
   		// when
   		log.info("delete 전: {}", item);
   		itemService.delete(item);
   		Item findItem = itemService.findById(itemId);
   		log.info("delete 후: {}", findItem);
   		// then
   		assertThat(findItem).isNull();
   	}
   	@Test
   	public void 전체조회_검색조건조회() throws Exception {
   		// given
   		Item item = Item.createItem("테스트 닉네임", "비밀번호", "테스트 제목", "테스트 내용", "이미지 경로");
   		itemService.save(item);
   		itemService.save(item);
   		itemService.save(item);
   		// when
   		List<Item> findItems = itemService.findAll();
   		// then
   		assertThat(findItems).isNotNull();
   		for (Item i : findItems) {
   			log.info("itemId: {}, title: {}", i.getId(), i.getTitle());
   		}
   	}
   	// CRUD 테스트 끝
   	// 추가 함수 테스트 시작
   	@Test
   	public void 페이지내아이템_페이징조회() throws Exception {
   		// given
   		for (int i = 0; i < 15; i++) { // 테스트 데이터 15개 생성
   			Item item = Item.createItem("테스트 닉네임" + i, "비밀번호", "테스트 제목" + i, "테스트 내용", "이미지 경로");
   			itemService.save(item);
   		}
   		ItemDefault searchItem = new ItemDefault();
   //
   		// when
   		// pagination setting
   		// 첫 번째 페이지 조회 (최신 10개)
   		searchItem.setPageIndex(1);
   		PaginationInfo paginationInfo = new PaginationInfo();
   		paginationInfo.setCurrentPageNo(searchItem.getPageIndex());
   		paginationInfo.setRecordCountPerPage(searchItem.getPageUnit());
   		paginationInfo.setPageSize(searchItem.getPageSize());
   //
   		searchItem.setFirstIndex(paginationInfo.getFirstRecordIndex());
   		searchItem.setLastIndex(paginationInfo.getLastRecordIndex());
   		searchItem.setRecordCountPerPage(paginationInfo.getRecordCountPerPage());
   //
   		List<Item> firstPage = itemService.findAllWithPage(searchItem);
   //
   		// 두 번째 페이지 조회 (나머지 5개)
   		searchItem.setPageIndex(2);
   		paginationInfo.setCurrentPageNo(searchItem.getPageIndex()); // 2페이지로 설정
   //
   		searchItem.setFirstIndex(paginationInfo.getFirstRecordIndex());
   		searchItem.setLastIndex(paginationInfo.getLastRecordIndex());
   		searchItem.setRecordCountPerPage(paginationInfo.getRecordCountPerPage());
   //
   		List<Item> secondPage = itemService.findAllWithPage(searchItem);
   		// then
   		assertThat(firstPage).isNotNull();
   		assertThat(firstPage.size()).isEqualTo(10);
   		assertThat(secondPage).isNotNull();
   		assertThat(secondPage.size()).isEqualTo(5);
   		// 첫 번째 페이지의 id가 두 번째 페이지보다 큰지 확인 (내림차순 정렬)
   		assertThat(firstPage.get(0).getId()).isGreaterThan(secondPage.get(0).getId());
   		// 로그 출력
   		log.info("=== 첫 번째 페이지 ===");
   		for (Item i : firstPage) {
   			log.info("itemId: {}, title: {}", i.getId(), i.getTitle());
   		}
   		log.info("=== 두 번째 페이지 ===");
   		for (Item i : secondPage) {
   			log.info("itemId: {}, title: {}", i.getId(), i.getTitle());
   		}
   	}
   //
   	@Test
   	public void 아이템이전이후_조회() throws Exception {
   		// given
   		Item item = null;
   		for (int i = 0; i < 5; i++) { // 테스트 데이터 5개 생성
   			item = Item.createItem("테스트 닉네임" + i, "비밀번호", "테스트 제목" + i, "테스트 내용", "이미지 경로");
   			itemService.save(item);
   		}
   		// when
   		List<Item> findItems = itemService.findPrevNextById(item.getId() - 1); // 마지막id-2, 마지막id-1, 마지막id 가 나와야 정상
   		List<Item> findItemsFirst = itemService.findPrevNextById(item.getId() - 4); // 첫번째id, 첫번째id+1 가 나와야 정상
   		List<Item> findItemsLast = itemService.findPrevNextById(item.getId()); // 마지막id-1, 마지막id 가 나와야 정상
   		// then
   		assertThat(findItems).isNotNull();
   		assertThat(findItems.size()).isEqualTo(3);
   		assertThat(findItemsFirst).isNotNull();
   		assertThat(findItemsFirst.size()).isEqualTo(2);
   		assertThat(findItemsLast).isNotNull();
   		assertThat(findItemsLast.size()).isEqualTo(2);
   		// 로그 출력
   		log.info("=== 아이템 이전 이후: findItems ===");
   		for (Item i : findItems) {
   			log.info("itemId: {}, title: {}", i.getId(), i.getTitle());
   		}
   		log.info("=== 아이템 이전 이후: findItemsFirst ===");
   		for (Item i : findItemsFirst) {
   			log.info("itemId: {}, title: {}", i.getId(), i.getTitle());
   		}
   		log.info("=== 아이템 이전 이후: findItemsLast ===");
   		for (Item i : findItemsLast) {
   			log.info("itemId: {}, title: {}", i.getId(), i.getTitle());
   		}
   	}
   //
   	@Test
   	public void 아이템총개수_조회() throws Exception {
   		// given
   		for (int i = 0; i < 10; i++) { // 테스트 데이터 10개 생성
   			Item item = Item.createItem("테스트 닉네임" + i, "비밀번호", "테스트 제목" + i, "테스트 내용", "이미지 경로");
   			itemService.save(item);
   		}
   		// when
   		ItemDefault searchItem = Item.createItem(null, null, null, null, null);
   		int findCnt = itemService.findTotalCount(searchItem);
   		// then
   		assertThat(findCnt).isNotNull();
   		assertThat(findCnt).isEqualTo(10);
   		// 로그 출력
   		log.info("=== 아이템 총 개수 findCnt:{} ===", findCnt);
   	}
   //
   	@Test
   	public void 검색자동완성() throws Exception {
   		// given
   		for (int i = 0; i < 10; i++) { // 테스트 데이터 10개 생성
   			Item item = Item.createItem("테스트 닉네임" + i, "비밀번호", "테스트 제목" + i, "테스트 내용", "이미지 경로");
   			itemService.save(item);
   		}
   		// when
   		List<String> result = itemService.findTitleListForSuggest("테스트 제");
   		// then
   		assertThat(result).isNotNull();
   		log.info("=== 자동완성 result: {} ===", result);
   	}
   }
   ```
   </div>
   </details>

<br>

**eGov 방식의 "검색(동적쿼리)+페이징, 자동완성(검색)"**   
=> 페이징은 egov꺼 라이브러리(PaginationInfo, Manager, Renderer) 사용

1. **"동적쿼리(검색), 페이징" 위한 엔티티 부모 만들어 상속! -> 페이징, 검색조건을 가짐**  

   egov 예제의 SampleDefaultVO.java 형태를 사용! (Serializable 제외)

   <details><summary><b>SampleDefaultVO.java</b></summary>
   <div markdown="1"><br>
   ```java
   @Getter @Setter
   @NoArgsConstructor
   @EqualsAndHashCode //메모리캐시 때문에 넣음(원래도 있는게 좋긴하지)
   public class ItemDefault {
   	/** 검색조건->카테고리 ID, NAME 등 선택 */
   	private String searchCondition = "";
   	/** 검색Keyword */
   	private String searchKeyword = "";
   	/** 검색사용여부 */
   	private String searchUseYn = "";
   	/** 현재페이지 */
   	private int pageIndex = 1;
   	/** 페이지갯수->페이지당 뷰에 나타낼 게시물 수 */
   	private int pageUnit = 10;
   	/** 페이지사이즈->5면 하단 네비게이션에 1 2 3 4 5 까지 표시 */
   	private int pageSize = 10;
   	/** firstIndex->페이지 출력 시작할 게시물 위치: (pageIndex-1)*recordCountPerPage */
   	private int firstIndex = 1;
   	/** lastIndex->페이지 출력 마지막 게시물 위치: (pageIndex)*recordCountPerPage */
   	private int lastIndex = 1;
   	/** recordCountPerPage->limit 쿼리용 */
   	private int recordCountPerPage = 10;
   }
   ```
   </div>
   </details>

2. **기능개발+TEST -> "검색(동적쿼리)+페이징, 자동완성(검색)"**

   **메소드 추가 및 XML쿼리 작성** -> 동적쿼리(검색)+페이징, 자동완성(검색)  

   - 동적쿼리(검색)+페이징을 합친이유: 기본 게시물조회 자체가 검색 키워드 빈값("")과 동일하기 때문  
     따라서 전체 조회 쿼리에 "동적쿼리 where,if-searchKeyword" + "limit,offset"구조를 사용!  
     +) 페이징을 위해 전체 게시물 수 조회 쿼리도 필수!
   - 페이징에 필요한 것 2가지: 변수3개(pageUnit, pageSize, pageIndex) + PaginationInfo클래스(egov)

     - 직접 설정하는 변수: pageUnit, pageSize
       - 페이지당 뷰에 나타낼 게시물 수: pageUnit
       - 하단 네비게이션 바에 표시할 페이지 수: pageSize  
         예: pageSize=5 라면, 1 2 3 4 5 가 출력
     - 웹에서 받아야할 변수(=현재 페이지 번호): pageIndex
     - PaginationInfo클래스(egov): Required Fields, 
       - Required Fields: 이 필드들은 페이징 계산을 위해 반드시 입력되어야 하는 필드 값
         - currentPageNo : 현재 페이지 번호 -> pageIndex 매치
         - recordCountPerPage : 한 페이지당 게시되는 게시물 건 수 -> pageUnit 매치
         - pageSize : 페이지 리스트에 게시되는 페이지 건 수 -> pageSize 매치
         - totalRecordCount : 전체 게시물 건 수 -> 서비스 로직으로 구하기 (+데이터도)
       - Not Required Fields: 이 필드들은 Required Fields 값을 바탕으로 계산해서 정해지는 필드 값
         - totalPageCount: 페이지 개수
         - firstPageNoOnPageList : 페이지 리스트의 첫 페이지 번호
         - lastPageNoOnPageList : 페이지 리스트의 마지막 페이지 번호
         - firstRecordIndex : 페이징 SQL의 조건절에 사용되는 시작 rownum. 
         - lastRecordIndex : 페이징 SQL의 조건절에 사용되는 마지막 rownum.
   - 페이징 쿼리 계산 원리: `LIMIT #{recordCountPerPage} OFFSET #{firstIndex}`  
     (참고: jpa의 jpql은 페이징의 limit쿼리 사용불가하고 제공되는 메소드를 사용)
     - pageUnit값이 recordCountPerPage가 된다.
     - (pageIndex-1)\*recordCountPerPage 수식이 firstIndex(페이지 출력 시작 게시물 위치)가 된다.   
       (pageIndex)\*recordCountPerPage 수식이 lastIndex(페이지 출력 마지막 게시물 위치)가 된다.  
       - pageUnit=5, pageIndex=2 라면 시작 게시물 위치는 (2-1)\*5=5이고 마지막은 2\*5=10이다.
   - 자동완성(검색) 원리: SampleDefaultVO의 searchCondition, searchKeyword를 활용!
     - searchCondition는 어떤 카테고리로 검색할지 담당하고,
     - searchKeyword는 검색 키워드를 담당한다.
   
   **컨트롤러에서 페이징과 자동완성 검색** 마무리 해보자.
   
      - 자동완성은 검색 키워드로 매칭되는 데이터 찾아서 JSON으로 응답하면 됨
   
        - <details><summary><b>자동완성 컨트롤러 예시 코드</b></summary>
          <div markdown="1"><br>
          ```java
          //Ajax 사용한 컨트롤러 -> 페이징도 사용했지만 그건 GalleryController 꺼로 함.
          @Controller
          @RequiredArgsConstructor
          @Slf4j
          public class AjaxController {
          	private final ItemServiceImpl itemService;
          //
          	@ResponseBody
          	@PostMapping("/suggestKeyword")
          	public List<String> suggestKeyword(HttpServletRequest request) throws Exception {
          	    String searchKeyword = URLDecoder.decode(request.getParameter("searchKeyword"), "utf-8");
          	    List<String> results = itemService.findTitleListForSuggest(searchKeyword);
          	    return results; // 자동으로 JSON으로 변환되어 응답됨
          	}
          }
          ```
          </div>
          </details>
   
   
      - 페이징은 PaginationInfo(페이징 데이터)와 ItemDefault(=1번에서 만든 SampleDefaultVO) 필요
   
   
      - 서비스 메소드 findAllWithPage, findTotalCount 를 사용해 각각 model, paginationInfo에 담음
   
        - <details><summary><b>페이징 컨트롤러 예시 코드</b></summary>
          <div markdown="1"><br>
          ```java
          @GetMapping()
          public String search(@ModelAttribute Item item, Model model) throws Exception {
          	return this.gallery(item, model); //HTTP말고 그냥 메소드 호출한거.(포워드,리다이렉트 아님)
          }
          @PostMapping() // ...?pageIndex=1 이런식으로 페이지 파라미터 넘어 올거임(pageIndex란 Item이 상속받고 있는 DefaultItem의 필드)
          public String gallery(@ModelAttribute Item item, Model model) throws Exception {
          	// item.setPageUnit(myDataSource.getPageUnit());
          	// item.setPageSize(myDataSource.getPageSize());
          	item.setPageUnit(10);
          	item.setPageSize(10);
          //
          	// pagination setting
          	PaginationInfo paginationInfo = new PaginationInfo();
          	paginationInfo.setCurrentPageNo(item.getPageIndex());
          	paginationInfo.setRecordCountPerPage(item.getPageUnit());
          	paginationInfo.setPageSize(item.getPageSize());
          //
          	item.setFirstIndex(paginationInfo.getFirstRecordIndex());
          	item.setLastIndex(paginationInfo.getLastRecordIndex());
          	item.setRecordCountPerPage(paginationInfo.getRecordCountPerPage());
          //
          	// List
              List<Item> items = itemService.findAllWithPage(item);
              List<ItemResDto> itemsResDto = items.stream().map(o -> new ItemResDto(o)).collect(Collectors.toList());
              int totCnt = itemService.findTotalCount(item);
          //
              model.addAttribute("itemsResDto", itemsResDto);
              paginationInfo.setTotalRecordCount(totCnt);
              // Pagination
              model.addAttribute("paginationInfo", paginationInfo);
              log.info("cnt: {}, resultList: {}", totCnt, items);
              return "jsp/gallery";
          }
          ```
          </div>
          </details>
   
3. **JSP Ver1: 페이징과 검색란**

   페이징은 `<ui: pagination` **형태로 사용 -> 이것이 PaginationTag 이다.**  
   ui 태그 라이브러리 선언 + linkPage 함수 작성 후 ui 태그 사용

   <details><summary><b>jsp 예시 코드 Ver1 - 페이징</b></summary>
   <div markdown="1"><br>
   ```jsp
   <%@ taglib prefix="ui" uri="http://egovframework.gov/ctl/ui"%>
   ...
   <script type="text/javascript">
       //pageNo는 사용한 ui태그가 알아서 담아준다.
   	function linkPage(pageNo) {
   		location.href = "/gallery?pageIndex=" + pageNo;
   	}
   </script>
   <body>
   ...
   ${resultList}
   	<ui:pagination paginationInfo="${paginationInfo}" type="image"
   		jsFunction="linkPage" />
   ...
   </body>
   ```
   </div>
   </details>

   <details><summary><b>jsp 예시 코드 Ver2 - 페이징(AJAX 적용)</b></summary>
   <div markdown="1"><br>
   **현대식으로 AJAX를 추가하여 SPA와 유사한 방식 적용법**<br>
   Ver1방식은 페이지 자체가 새로고침되는 거라면, 이 방식은 화면의 원하는 부분만 바뀐다.<br>
   **기존 코드의 js 함수부분 수정(태그변경, AJAX통신) + 변경할 태그에 id 지정하면 됨!**<br>
   jquery 문법을 활용해서 ajax 적용 했음. (jstl은 jpa 표준 태그 라이브러리 - c, fmt 등)
   ```jsp
   <%@ page contentType="text/html; charset=UTF-8"%>
   <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
   <%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt"%>
   <%@ taglib prefix="ui" uri="http://egovframework.gov/ctl/ui"%>
   <%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %>
   <%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
   <!DOCTYPE html>
   <html>
   <head>
   <meta charset="UTF-8">
   <title>Insert title here</title>
   <link rel="stylesheet" href="/css/basic.css"/>
   <link rel="stylesheet" href='/css/gallery.css'/>
   <link rel="stylesheet" href='/css/jqueryui.css'/>
   <script src="<c:url value='/js/jquery.js'/>"></script>
   <script src="<c:url value='/js/jqueryui.js'/>"></script>
   </head>
   <script type="text/javascript">
   	//ui:pagination에서 pageNo 파라미터 자동으로 구해옴
   	function linkPageAjax(pageNo) {
   		//location.href = "/gallery?pageIndex=" + pageNo;
           $.ajax({
               url: '/gallery',
               type: 'post',
               data: {
                   pageIndex: pageNo
               }
           }).done(function(fragment) {
               $('#content_area').html(fragment);
           });
   	}
   </script>
   <body>
   <div id="content_area" >
   	${resultList} ... 생략
       <ui:pagination paginationInfo="${paginationInfo}" type="image"
                      jsFunction="linkPageAjax" />
   </div>
   </body>
   </html>
   ```
   </div>
   </details>

   검색의 자동완성은 애초에 검색란에 검색 시 ajax+jquery의 auto 사용하여 로드

   <details><summary><b>jsp 예시 코드 - 검색란(+자동완성): 얜 애초에 AJAX</b></summary>
   <div markdown="1"><br>
   jquery 기능인 autocomplete(자동완성)이 중요. 특히, jquryui.js 가 꼭 필요.
   ```javascript
   // ajax사용 - 자동완성 
   $(function() {
   	// jquery autocomplete 코드를 생성한다.
   	$("#searchKeyword")
   			.autocomplete(
   					{
   						source : function(request, response) {
   							$
   									.ajax({
   										url : '/suggestKeyword',
   										type : 'post',
   										contentType : "application/x-www-form-urlencoded; charset=UTF-8",
   										data : {
   											searchKeyword : request.term
   										},
   										dataType : 'json',
   										success : function(returnData) {
   											// @ResponseBody 사용 시: response(returnData);
   											// ModelAndView 사용 시: response(returnData.nameList);
   											response(returnData);
   										}
   									});
   						},
   						minLength : 1,
   						select : function(event, ui) {
   							$("#searchKeyword").val(this.value);
   						}
   					});
   });
   function notNullCheck(value) {
   	return !(value === '' || value == null || (typeof value == 'object' && !Object
   			.keys(value).length));
   }
   // ajax사용 - 검색 작업 -> HTTP URL이 페이징과 동일!
   function sampleSearch() {
   	if (notNullCheck($('#searchKeyword').val())) {
   		$.ajax(
   				{
   					url : '/gallery',
   					type : 'post',
   					data : {
   						searchCondition : $(
   								'#searchCondition option:selected').val(),
   						searchKeyword : $('#searchKeyword').val()
   					}
   				}).done(function(fragment) {
   			$('#content_area').replaceWith(fragment);
   		});
   	} else {
   		const errorMessage = '<spring:message code="search.error" />';
   		alert(errorMessage);
   	}
   }
   ```
   - source 함수: Autocomplete의 소스코드 설정 -> 사용자가 입력 필드에 텍스트를 입력할 때마다 호출 (input 이벤트 감지는 Autocomplete API에 구현되어 있을거임)
   - request.term: 사용자가 입력 필드에 입력한 현재 텍스트
   - encodeURIComponent(request.term): 입력한 텍스트를 URL 인코딩하여 서버로 전송 -> 특수 문자가 올바르게 전송
   - minLength: 1: 최소 1글자 이상 입력해야 자동 완성 기능이 작동
   - select: 자동 완성 목록에서 항목을 선택할 때 호출 -> searchName 필드로 선택 값(this.value) 저장
   </div>
   </details>

4. **하단 네비게이션바 커스텀은? -> [공식문서](https://www.egovframe.go.kr/wiki/doku.php?id=egovframework%3Arte%3Aptl%3Aview%3Apaginationtag) 잘 정리되어 있음**

   먼저 XML에 Pagination빈 등록필요 -> Renderer(egov꺼 상속&구현), Manager(egov꺼 바로사용)  
   빈 등록 안해도 jsp에서 ui태그 불러와 paginationInfo속성으로 사용해도 기본값으로 되긴 함.   
   다만, 이 빈까지 등록해야 하단 네비게이션바를 직접 꾸밀 수 있다.

   동작 설명: PaginationTag인 ui태그 사용 시

   - 어떤 PaginationRenderer를 사용할지 PaginationManager에게 위임
   - 실제 페이징을 위한 작업은 PaginationManager가 반환한 PaginationRenderer이 담당
   - PaginationInfo는 페이징 기능 렌더링에 필요한 데이터들이 담겨있는 클래스

   **PaginationRenderer 커스텀 예시:**

   - AbstractPaginationRenderer를 상속받고 생성자를 만들면 됨. 이때, "<a태그와 <img태그"를 건들 수 있음
   - 생성되는 하단 페이지이동란 태그를 직접 커스텀 할 수 있어서 적당한 class를 지정하여 폰트도 css로 쉽게 적용해주자.
   - 부트 사용 시 resources/static 하위에 img를 둬서 관리하자.

   <details><summary><b>ImagePaginationRenderer 클래스 구현 예시 코드</b></summary>
   <div markdown="1"><br>
   ```java
   public class ImagePaginationRenderer extends AbstractPaginationRenderer implements ServletContextAware {
   	private ServletContext servletContext;
   	public ImagePaginationRenderer() {
   	}
   //
   	public void initVariables(ServletContext servletContext) {
   		// String strWebDir =
   //		String strWebDir = servletContext.getContextPath() + "/images/pagination/";
   		String strWebDir = "/images/pagination/"; //boot는 resources/static 하위 자동으로 탐색
   		//class='page-link'와 class='page-link-act'는 css 적용위해 설정.
   		firstPageLabel = "<a class='page-link' href=\"#\" onclick=\"{0}({1}); return false;\">" + "<image src='" + strWebDir
   				+ "bt_first.gif' border=0/></a>&#160;";
   		previousPageLabel = "<a class='page-link' href=\"#\" onclick=\"{0}({1}); return false;\">" + "<image src='" + strWebDir
   				+ "bt_prev.gif' border=0/></a>&#160;";
   		currentPageLabel = "<a class='page-link-act'><strong>{0}</strong></a>&#160;";
   		otherPageLabel = "<a class='page-link' href=\"#\" onclick=\"{0}({1}); return false;\">{2}</a>&#160;";
   		nextPageLabel = "<a class='page-link' href=\"#\" onclick=\"{0}({1}); return false;\">" + "<image src='" + strWebDir
   				+ "bt_next.gif' border=0/></a>&#160;";
   		lastPageLabel = "<a class='page-link' href=\"#\" onclick=\"{0}({1}); return false;\">" + "<image src='" + strWebDir
   				+ "bt_last.gif' border=0/></a>&#160;";
   	}
   //
   	public void setServletContext(ServletContext servletContext) {
   		this.servletContext = servletContext;
   		initVariables(servletContext);
   	}
   }
   ```
   </div>
   </details>
   <details><summary><b>xml 빈 등록 예시 코드</b></summary>
   <div markdown="1"><br>
   resources/spring/context-common.xml
   ```xml
   <!-- For Pagination Tag -->
   <bean id="imageRenderer" class="com.secretgallery.tag.ImagePaginationRenderer"/>
   <bean id="paginationManager" class="org.egovframe.rte.ptl.mvc.tags.ui.pagination.DefaultPaginationManager">
       <property name="rendererType">
           <map>
               <entry key="image" value-ref="imageRenderer"/> 
           </map>
       </property>
   </bean>
   ```
   </div>
   </details>

5. **자동완성 css 스타일링 방법은?**

   아래처럼 ui를 활용하자. 이렇게 해야 css 스타일링이 적용 됨.

   ```css
   .ui-autocomplete {
   color: black;
   background: white;
   width: 120px;
   }
   ```

<br>

검증(자캍..) -> API 말공 JSP(웹)란걸 적어.

예외 -> API 말공 JSP(웹)란걸 적어.

흠... 요곤  리팩 파트 하고 하는거다.





리팩토링-application&java config / xml 설정들

application.yml 관련 예시는 JPA 부분 참고, 나머지 설정은 리팩토링 보면 알 수 있음.

application.properties(yml)은 런타임 시 다양한 환경에서 동작할 수 있도록 필요한 옵션들을 제공하는데 사용된다.  
"부트"는 디폴트로 이를 설정파일로 사용하며, "순수스프링"은 기본 프로젝트에 애초에 없다.

"부트"는 보통 properties(yml) & java config 로 설정을 하며, "순수스프링"은 xml로 설정하는 편이다.  
=> 요즘은 "부트"를 기본으로 사용하다보니 java config 방식을 잘 알아두자.

특히, "순수스프링"은 xml이 web.xml > context-servlet.xml > context-common.xml 순으로 크게 나뉜다.  
꼭 안나눠도 설정이 적용은 되지만 유지보수를 위해서라도 분리해주고,  
"부트"의 경우 src/main/resources 하위(classpath)를 사용하는게 원칙이라 xml을 혼용할 때 이곳으로 위치를 전부 옮겼다는 점을 이해하자. (webapp/WEB-INF 하위를 classpath로 부트는 제공하지 않기 때문)  
=> "부트"가 자동설정 해주는 부분은 xml 비추천, xml로 뷰리졸버 직접등록 이런건 자동설정과 충돌날 수 있음.

리팩토링-한개한개..

0. 로그레벨(SQL쿼리), DataSource, 프로필&외부설정 등 JPA에서 정리했던 설정파일 참고(Java Config & properties)

   참고: application.properties에 로그레벨 설정 매우 간단

   ```properties
   # 로그레벨이 기본값 info인데, aop랑 exception에서 debug사용중이라 debug레벨로 설정
   logging.level.com.secretgallery.aop=DEBUG
   logging.level.com.secretgallery.exception=DEBUG 
   # MyBatis 관련 로깅 레벨 설정 (이것도 쿼리는 debug로 나와서 레벨설정 필요)
   logging.level.org.mybatis=DEBUG
   logging.level.org.apache.ibatis=DEBUG
   ```

   **이 설정 관련도 뭐.. JPA에서 다 얘기했당. 여선 JPA말만 해주고 아래 xml들이나 잘 하자이**

1. 메시지 국제화 -> XML, Java Config 둘 다 소개 (context-common.xml, context-servlet.xml 적용함)

   > 순수스프링은 xml에서 HandlerMapping지정해서 인터셉터 등록하면 해당 핸들러만 사용하다보니 문제없이 정상 동작하지만,  
   > 부트는 항상 여러 HandlerMapping을 자동등록 하기 때문에 순수스프링처럼 1개만 지정해버리면 다른 HandlerMapping들에 인터셉터가 등록이 되지 않는 문제가 발생한다.  
   >
   > 부트 사용하는 프로젝트의 경우 xml에 `<mvc:interceptors>` 패턴이나 부트가 권장하는 Java Config를 사용해서 "모든 핸들러매핑에 인터셉터를 등록"하자.

   context-common.xml에 messageSource빈과 국제화빈 등록,  
   context-servlet.xml에 해당 인터셉터를 등록  
   message/meesage-common.properties, *\_ko.properties, *\_en.properties 를 생성

   **메시지 국제화**는 "핸들러매핑에 인터셉터"를 등록하는 부분이 필요하다.   
   "디스패처서블릿->HandlerMapping->인터셉터 거쳐서 컨트롤러 진입"을 해야하기 때문! (Locale 위해)

   - Java Config나 \<mvc:interceptors>(xml)패턴으로 인터셉터를 추가하게 되면 부트는 "모든 핸들러매핑"에 인터셉터를 추가해준다!

   <details><summary><b>XML 코드: (이거 적용함)</b></summary>
   <div markdown="1"><br>
   resources/spring/context-common.xml
   ```xml
   <!-- -->
   	<!-- 메시지소스와 국제화 -->
   	<!-- set message source -->
   	<bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
   		<property name="basenames">
   			<list>
   				<value>messages.message-common</value>
   			</list>
   		</property>
   	</bean>
   	<!-- setting Locale -->   
   	<bean id="localeChangeInterceptor" class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"
   		p:paramName="lang" />
   	<bean id="localeResolver" class="org.springframework.web.servlet.i18n.SessionLocaleResolver" />
   ```
   resources/spring/context-servlet.xml
   ```xml
   	<!-- 부트처럼 "모든 핸들러매핑에 인터셉터 등록" 방안 -->
   	<mvc:interceptors>
   		<mvc:interceptor>
   			<mvc:mapping path="/*" />
   			<ref bean = "localeChangeInterceptor" /> <!-- 메시지 국제화 등록 -->
   		</mvc:interceptor>
   	</mvc:interceptors>
   ```
   </div>
   </details>
   
   <details><summary><b>Java Config 코드:</b></summary>
       <div markdown="1"><br>
           ```java
           @Configuration
           public class WebConfig implements WebMvcConfigurer {
           @Override
           public void addInterceptors(InterceptorRegistry registry) {
           registry.addInterceptor(localeChangeInterceptor()); //국제화 인터셉터 등록
           }
           //국제화 빈 -> 파라미터 lang 가져오는 용도
           @Bean
           public LocaleChangeInterceptor localeChangeInterceptor() {
           LocaleChangeInterceptor interceptor = new LocaleChangeInterceptor();
           interceptor.setParamName("lang");
           return interceptor;
           }
           //국제화 빈 -> 세션사용 및 Locale 자동 생성 용도
           @Bean
           public LocaleResolver localeResolver() {
           SessionLocaleResolver resolver = new SessionLocaleResolver();
           resolver.setDefaultLocale(Locale.KOREA); // 또는 원하는 기본 로케일
           return resolver;
           }
           //메시지소스 빈 -> 국제화 빈과 항상 세트로 사용하자.
           @Bean
           public MessageSource messageSource() {
           ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
           messageSource.setBasenames(
           "message.message-common", 
           "org.egovframe.rte.fdl.idgnr.messages.idgnr",
           "org.egovframe.rte.fdl.property.messages.properties"
           );
           messageSource.setCacheSeconds(60);
           messageSource.setDefaultEncoding("UTF-8");
           return messageSource;
           }   
           }
           ```
       </div>
   </details>
   
   **Java 방식은 JPA에서 이미 소개했넹.(여선 안해도 되긋다잉)**
   
   메시지 사용: **JSP**에서 `<spring:message code="Login.form.id"/>` 이런식으로 사용.(propeties의 Login.form.id 매핑)
   
   국제화 사용: url에 `http://example.com?lang=en` 처럼 파라미터 담아 요청!  
   
   - lang파라미터 없어도 헤더에 자동 등록된 lang보고 국제화 사용 된다.
   - 즉, 미국에서 접속 시 브라우저는 자국 언어인 en을 lang으로 헤더에 자동 등록되는 특징을 이용가능!
   

2. **외부설정(property)** -> Java Config 방식 소개 (참고: eGov 라이브러리 지원-EgovPropertyServiceImpl)

   1)application.properties에 값을 @ConfigurationProperties로 불러와 사용하는게 현대적인 방법!  
   => 프로필을 properties 사용중이니까 구분 쉽게 하기 위해서라도 properties 사용ㄱ   
   => Egov 라이브러리 미사용.
   
   - **운영환경은 외부.properties 도 함께 사용하자!** (외부설정이 내부보다 우선순위)   
   => 불러오는거 매우 간단: `spring.config.import=optional:file:경로`
   
   <details><summary><b>@ConfigurationProperties 사용코드(+외부설정 포함): 이거 적용함</b></summary>
   <div markdown="1"><br>
   3개 자바파일 + 내부,외부 application.properties 필요<br>**application.properties -> 내부 resources에서 코드**
   ```properties
   # 내부설정.property + 외부설정.properties(ex: pageUnit=10)
   # file:../prod.properties란 프로젝트 상위에 잇는 외부설정
   spring.config.import=optional:file:../prod.properties 
   my.datasource.pageUnit=10
   my.datasource.pageSize=10
   my.datasource.imgPath=C:/images-spring/
   ```
   **MyDataSource.java -> 객체로 사용할 클래스**
   ```java
   @Slf4j
   @Data
   public class MyDataSource {
   	private int pageUnit;
   	private int pageSize;
   	private String imgPath;
   	// 생성자
   	public MyDataSource(int pageUnit, int pageSize, String imgPath) {
   		this.pageUnit = pageUnit;
   		this.pageSize = pageSize;
   		this.imgPath = imgPath;
   	}
   //
   	@PostConstruct // 로딩완료 후 바로 실행 (로그 확인용)
   	public void init() {
   		log.info("init: pageUnit={}, pageSize={}, imgPath={}", pageUnit, pageSize, imgPath);
   	}
   }
   ```
   **MyDataSourceProperties.java -> @ConfigurationProperties로 application.properties 내용을 JVM에 로드**
   ```java
   /**
    * 외부설정:
    * @ConfigurationProperties 로 application.properties 에 저장한 my.datasource 하위 내용
    * 가져와서 "자바 객체" 로 변환 + 검증까지
    */
   @Slf4j
   @Getter @Setter
   @ConfigurationProperties("my.datasource")
   //@Validated
   public class MyDataSourceProperties {
   //    @NotEmpty
       private int pageUnit;
       private int pageSize;
       private String imgPath;
       public MyDataSourceProperties() { // 기본 생성자
       	log.info("properties 기본생성자 TEST");
       }
       public MyDataSourceProperties(int pageUnit, int pageSize, String imgPath) {
       	log.info("properties 일반생성자 TEST");
           this.pageUnit = pageUnit;
           this.pageSize = pageSize;
           this.imgPath = imgPath;
       }
   }
   ```
   **MyDataSourceConfig.java -> @EnableConfigurationProperties로 @ConfigurationProperties를 빈 사용 활성화**<br>참고) 바로 사용해도 되지만 객체로 쉽게 사용할 수 있게 추가로 `MyDataSource.java` 를 빈 등록 했다.
   ```java
   /**
    * 외부설정:
    * @EnableConfigurationProperties 로 MyDataSourceProperties 를 사용 및 스프링 빈
    * @Import 를 통해서 "컴포넌트 스캔 대상 꼭 지정하기!"
    */
   @Slf4j
   @EnableConfigurationProperties(MyDataSourceProperties.class)
   public class MyDataSourceConfig {
       private final MyDataSourceProperties properties;
       public MyDataSourceConfig(MyDataSourceProperties properties) {
           this.properties = properties;
       }
   //
       @Bean
       public MyDataSource getMyDataSource() {
           return new MyDataSource(
                   properties.getPageUnit(), properties.getPageSize(), properties.getImgPath()
           );
       }
   }
   ```
   </div>
   </details>
   
   **위 방식 JPA에서 이미 소개 했넹.****
   
   2)eGov 라이브러리 사용하여 빈 등록해서 XML이나 Java에서 간단히 할 수 있게 지원 중이다.   
   => JAVA ex: EgovPropertyServiceImpl 빈 등록하며 setProperties()로 사용할 변수(Map) 넣으면 됨.  
   
   근데, 위 방식처럼 application.properties에 변수 등록해서 사용하는게 더 좋을것 같음(할 수 있는게 많으니)
   
   <details><summary><b>eGov 사용코드(Java Config):</b></summary>
   <div markdown="1"><br>
   ```java
   @Configuration
   public class EgovConfigProperties {
   	@Bean(destroyMethod="destroy")
   	public EgovPropertyServiceImpl propertiesService() {
   		Map<String, String> properties = new HashMap<>();
   		properties.put("pageUnit", "10");
   		properties.put("pageSize", "10");
   //
   		EgovPropertyServiceImpl egovPropertyServiceImpl = new EgovPropertyServiceImpl();
   		egovPropertyServiceImpl.setProperties(properties);
   		return egovPropertyServiceImpl;
   	}
   }
   //
   //test code: 다양한 get메소드 제공
   private final EgovPropertyService propertiesService; //빈 가져옴
   propertiesService.getInt("pageUnit"); //10
   ```
   </div>
   </details>
   
3. 캐시(메모리, 웹) -> Java Config 사용 (XML로만은 cacheControl빈 제어가 한계)  
   **이것도 딱희.. XML안쓰니까 JPA에서 이미 다 정리함. JPA꺼 보라해두자.**

   > reload: 타임리프는 properties에 캐시 사용X 하여 reload가 가능한데, JSP는 reloadable="true"가 기본값이라 톰캣이  자동 컴파일 하면서 reload가 이미 제공!

   **브라우저 캐시는?**   
   "정적리소스 핸들러매핑"은 XML에서 `<mvc:resources mapping="/**" location="classpath:/static/" />` 이런식으로 가능,  
   그러나 setCacheControl 같은건 Java 코드로 해야해서 xml 그냥 하지마! -> JPA에서 한 것 참고

   **메모리캐시는?** -> 마찬가지로 JPA에서 한 것 참고  
   단, eGov적용한 이 프로젝트에선 페이징을 다른 방식으로 했었기 때문에 메모리캐시가 약간 다름.

   eGov 플젝에선 하필 URL을 studio/page/itemId 이런식으로 안해서 그냥 URL param으로 넘김 (이건 좀 아쉬움. 이건 JPA로 했던 플젝 방식이 더 좋은듯)

   - spring-boot-starter-cache, @EnableCaching 설정은 기본임!
   - `@Cacheable(value = "items", key = "#searchItem.pageIndex")` 이런식으로 직접 필드를 지정해줬음 (JPA꺼랑 비교해보면 이해 될 거임)
     - **주의**: key를 Object로 접근할 경우 @EqualsAndHashCode로 값이 구분되게 꼭 설정해야 함.  
       @EqualsAndHashCode는 이름 그대로 해당 메소드 자동 생성해주는 롬복
     - 참고로 조건부도 지정 가능: `@Cacheable(value = "items", key = "#searchItem.searchKeyword + '_' + #searchItem.pageIndex", condition = "#searchItem.searchKeyword != null && !#searchItem.searchKeyword.isEmpty()")`
   - 수동 cacheManager 빈 등록 설정으로 캐시 메모리 용량까지 설정하는걸 추천! (JPA꺼 참고)
   - 기존 타임리프 플젝 웹에서 캐시는 "페이징 게시물 조회 캐시" 흐름이 좀 복잡 **-> eGov적용 해본 웹 플젝에서 개선**
     - 게시물 페이지별 조회, 게시물 전체 개수: @Cacheable -> 캐시 없으면 기록 및 조회
     - 게시물 페이지별 조회(게시물 수정): @CachePut -> 캐시 있어도 기록 및 조회
       - **정정:** 그냥 수정도 @CacheEvict(key=해당 페이지) 로 해당 페이지만 캐시 초기화 하자.  
     - 게시물 추가, 게시물 삭제: @CacheEvict -> 캐시 초기화

   **테스트 방법**: 웹은 F12-네트워크 체크, 메모리는 db쿼리 유무 체크(properties에서 쿼리로그레벨 설정)

   <details><summary><b>적용한 전체 코드 참고:</b></summary>
   <div markdown="1"><br>
   pom.xml
   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-cache</artifactId>
   </dependency>
   ```
   application.properties
   ```properties
   # MyBatis 관련 로깅 설정
   logging.level.org.mybatis=DEBUG
   logging.level.org.apache.ibatis=DEBUG
   ```
   메인함수.java
   ```java
   @EnableCaching // Spring Boot Cache 사용을 선언
   public class EgovBootApplication {...}
   ```
   ItemDefault.java -> ItemServiceImpl에서 사용하는 파라미터
   ```java
   @EqualsAndHashCode
   public class ItemDefault {...}
   ```
   ItemServiceImpl.java
   ```java
   //CRUD
   @Override
   @Transactional // 쓰기모드
   @CacheEvict(value = {"items", "totalCount"}, allEntries = true) //캐시 초기화
   public Long save(Item item) throws Exception {
       return itemMapper.save(item);
   }
   @Override
   @Transactional // 쓰기모드
   @CacheEvict(value = {"items", "totalCount"}, allEntries = true)
   public Long delete(Item item) throws Exception {
       // TODO Auto-generated method stub
       return itemMapper.delete(item);
   }
   @Override
   @Transactional // 쓰기모드
   @CacheEvict(value = "items", key = "#item.pageIndex") //totalCount는 그대로
   public Long update(UpdateItemDto item) throws Exception {
       // TODO Auto-generated method stub
       return itemMapper.update(item);
   }
   //추가메소드
   @Override
   @Cacheable(value = "items", key = "#searchItem.pageIndex") //value 로 꼭 캐시 영역을 지정하여 구분
   public List<Item> findAllWithPage(ItemDefault searchItem) throws Exception {
   	// TODO Auto-generated method stub
   	return itemMapper.findAllWithPage(searchItem);
   }
   @Override
   @Cacheable(value = "totalCount") //totalCount는 공통으로 사용하니 key로 구분 필요 없지 
   public int findTotalCount(ItemDefault searchItem) throws Exception {
   	// TODO Auto-generated method stub
   	return itemMapper.findTotalCount(searchItem);
   }
   ```
   </div>
   </details>

4. Validation-Jakarta Commons -> xml 활용 (context-common.xml)

   > **API의 경우 클라쪽 "검증"은 서버가 할 일이 아니다(JS는 프론트쪽 개발진이 해야지!)**  
   > **웹의 경우 클라와 서버쪽 둘 다 "검증"**해주는게 좋다.
   >
   > **API의 "예외"**의 경우 서버는 **JSON으로 변경된 데이터를 “Valid(검증)”**하는거라서 **JSON→DTO매핑될 때 에러나 그 시점에 다양한 에러(주로 서비스로직)들은 “Exception(예외)”**으로 해결!
   > **=> 웹은 “검증”만으로 충분하지만 API는 “검증+예외”가 필요!**  
   > => 근데, 막상 해보니 웹&API 둘다 "검증+예외"를 적용 했다. eGov에선 웹에 에러페이지만 연동해주는게 아니라 "예외"까지 굳이 하더라?
   >
   > eGov가이드에선 계속 Jakarta Valid 방식을 사용하더라.
   >
   > 순수스프링의 Bean Validation 방식이 내가하던 기존 방식이고, 자카트라 방식과는 조금 다름.  
   > Bean Vaildation 방식 예시:
   >
   > 1. DTO 클래스에 검증 어노테이션(`@NotNull` 등) 적용하여 검증기에게 규칙 전달
   > 2. 컨트롤러에서 `@Validated` 어노테이션으로 검증 활성화 (스프링프레임워크의 LocalValidatorFactoryBean이 사용됨)
   > 3. `BindingResult`로 검증 결과 수집
   > 4. 오류출력: 타임리프는 th:error로 자동으로 bindingresult에서 해당필드 검증 오류있나 체크해서 등록해둔 오류메시지-@NotNull("이미지가 없습니다")를 출력  
   >    JSP는 form:error로 할 수 있고,  
   >    직접 bindingresult를 가져와 사용해도 된다.

   자카트라는 JSP에 validator 태그 사용시 "자동으로 JS검증 코드 생성"해줌. 즉, 클라쪽도 검증 자동 지원.  
   => 원래 Bean Validation방식은 컨트롤러 쪽에서 검증(서버단)하고 클라에선 직접 JS검증 코드 만들었었음.

   빈은 스프링 모듈의 DefaultBeanValidator, DefaultValidatorFactory 사용

   Jakarta Commons Validation 방식 예시:

   1. 제공된 **validator-rules.xml** 사용 및 기본제공 룰 말고 **커스텀 룰 추가**하는법: [공문](https://www.egovframe.go.kr/wiki/doku.php?id=egovframework:rte:ptl:validation:add_rules_in_commons_validator)

   2. **validation.xml, validator.jsp, URL매핑** : 공통 규칙 정의 (서버+클라이언트)

      1. validation.xml로 원하는 규칙 정의 + 원하는 메시지 설정(=5번에서 설명) message-common.properties

      2. context-common.xml에 빈 등록 - DefaultBeanValidator, DefaultValidatorFactory

      3. context-servlet.xml이나 컨트롤러에 validator.jsp URL등록 (태그로 JS검증 코드 자동생성 목적)  
         부트는 그냥 "컨트롤러"에서 해라!! 자동 설정이랑 겹쳐서 머리아프다.

         참고: validator.jsp -> "/validator.do" 와 매핑 (자동으로 룰에 따른 메소드가 생성되는것 같더라)

         ```xml
         <!-- validator.jsp -->
         <%@ page language="java" contentType="javascript/x-javascript" %>
         <%@ taglib prefix="validator" uri="http://www.springmodules.org/tags/commons-validator" %>
         <validator:javascript dynamicJavascript="false" staticJavascript="true"/>
         ```

   3. JSP validator 태그 적용해보기 -> 클라단 검증

      적용 예시: 버튼 type을 submit이 아닌 button으로 하여 js함수(=test) 검증 후 submit하도록 하기!

      ```xml
      <%@ taglib prefix="validator" uri="http://www.springmodules.org/tags/commons-validator" %> 
      <!-- ...등 import -->
      <script type="text/javascript" src="<c:url value="/validator.do"/>"></script>
      <validator:javascript formName="updateItemDto" staticJavascript="false" xhtml="true" cdata="false"/>
      <script type="text/javascript">
      function test(form){
      	if(!validateUpdateItemDto(form)){ //자동 생성된 검증 메소드 사용한 것
      		return;
      	}else{
      		form.submit(); //valid 통과!
      	}
      }
      </script>
      <button class="btn btn-light m-0" type="button" onclick="redirectSavedBgm(), test(this.form)" .../>
      ```

   4. Spring MVC Controller 적용해보기 -> 서버단 검증

      적용 예시: form taglib를 활용하자 + modelAttribute필수 + form:error필수

      ```java
      private final DefaultBeanValidator beanValidator; //빈 주입
      @PostMapping("item/{itemId}")
      public String studioIdUpdate(@ModelAttribute UpdateItemDto form, Model model) throws Exception {
          beanValidator.validate(form, bindingResult); //@Validated 미사용은 직접 해줘야 함.
          if(bindingResult.hasErrors()) return 수정폼;
      ```

      ```xml
      <%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%>
      <form:form action=""
                 method="post" modelAttribute="updateItemDto">
      <input type="password" class="no-spin" id="password" name="password" value="${item.password}" ...생략 />
      <form:errors id="password" name="password" path="password" />
      ```

      +번외) 직접 bindingResult가져와 jsp에서 사용하고 싶은경우?

      ```java
      @PostMapping("item/{itemId}")
      public String studioIdUpdate(@ModelAttribute UpdateItemDto form, Model model) throws Exception {
          beanValidator.validate(form, bindingResult); //@Validated 미사용은 직접 해줘야 함.
          if(bindingResult.hasErrors()) {
              model.addAttribute("bindingResult", bindingResult); //서버단 Valid결과 알려주는것 (직접 에러 커스텀 하려고 추가했음. form:error만 사용할경우 이 코드 필요없음)
      ... 생략
      ```

      ```xml
      <div class="field-error">
      	<%-- <c:if test="${not empty bindingResult.fieldErrors['password']}"> --%>
          <c:if test="${not empty bindingResult.fieldErrors}">
              비밀번호 오류
              <%-- 비밀번호 오류: <c:out value="${bindingResult.fieldErrors}" /> --%>
          </c:if>
      </div>
      ```

   5. validator 태그 검증한 클라 에러 메시지와 controller에 bindingresult에 검증한 서버 에러 메시지

      클라단 검증의 경우 validater-rule.xml 를 보면 msg="errors.required" 이런 코드 체크!  
      message.properties에서 errors.required 관련 메시지로 검증 메시지(alert)를 출력한다.

      서버단 검증의 경우 타임리프로 했던 th:error와 유사하게 form:error으로 가능  
      둘 다 bindingResult 결과로 검증결과를 얻어서 message.properties의 메시지로 폼에 출력해주고  
      Bean Valid 방식으로 @NotNull("메시지")로 했다면 해당 메시지를 출력해준다.   
      => 직접 모든걸 하고 싶으면 model로 bindingResult를 넘겨서 jsp에서 가공하여 출력해도 된다.

      여기선 message-common.properties를 활용했다.  
      연동은 validator.xml에서 설정 가능하고, validator-rule.xml의 msg에서도 설정 가능하다.

      ```properties
      #validator.xml에 연동한 메시지
      updateItemDto.password=비밀번호는 필수 입력 항목입니다.~!
      #validator-rule.xml에 msg필드에 자동으로 연동된 메시지
      errors.required={0} 은 필수 입력값입니다.~!~!
      ```

      - 클라단 메시지든 서버단 메시지든 두 메시지가 전부 출력된다. 하나로 통일해서 사용하자.  
        예로 updateItemDto.password를 지우고 errors.required만 사용

   **클라 검증 메시지, 서버 검증 메시지 예시:**

   <img src="/images/2023-12-02-CHECK_LIST_SPRING/image-20250406231747392.png" alt="image-20250406231747392" style="zoom:80%;" /> 

   <img src="/images/2023-12-02-CHECK_LIST_SPRING/image-20250406231709336.png" alt="image-20250406231709336" style="zoom:80%;" />

   **번외인 직접 bindingresult가져와 jsp에서 커스텀한 방식 예시(코드는 앞에서 언급한것 동일):**

   <img src="/images/2023-12-02-CHECK_LIST_SPRING/image-20250406231558527.png" alt="image-20250406231558527" style="zoom: 80%;" /> 

   <details><summary><b>xml 설정 코드와 message 예시:</b></summary>
   <div markdown="1"><br>
   **validator-rule.xml**
   ```xml
   <form-validation>
      <global>
         <validator name="required"
               classname="org.springmodules.validation.commons.FieldChecks"
                  method="validateRequired"
            methodParams="java.lang.Object,
                          org.apache.commons.validator.ValidatorAction,
                          org.apache.commons.validator.Field,
                          org.springframework.validation.Errors"
                     msg="errors.required">
             ...
   ```
   **validator.xml**
   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE form-validation PUBLIC 
       "-//Apache Software Foundation//DTD Commons Validator Rules Configuration 1.1//EN" 
       "http://jakarta.apache.org/commons/dtds/validator_1_1.dtd">
   <form-validation>
       <formset>
           <form name="updateItemDto">
               <!-- id 필드: 필수 값 -->
               <field property="id" depends="required">
                   <arg0 key="updateItemDto.id" />
               </field>
               <!-- nickname 필드: 필수 값 -->
               <field property="nickname" depends="required">
                   <arg0 key="updateItemDto.nickname" />
               </field>
               <!-- password 필드: 숫자만 허용 -->
               <field property="password" depends="required,integer">
                   <arg0 key="updateItemDto.password" />
                   <arg1 key="updateItemDto.password.integer" />
               </field>
               <!-- title 필드: 필수 값 -->
               <field property="title" depends="required">
                   <arg0 key="updateItemDto.title" />
               </field>
               <!-- content 필드: 필수 값 -->
               <field property="content" depends="required">
                   <arg0 key="updateItemDto.content" />
               </field>
               <!-- pageIndex 필드 -->
               <field property="pageIndex" >
               </field>
           </form>
       </formset>
   </form-validation>
   ```
   **context-common.xml**
   ```xml
   <!-- jakarta common validation 빈 등록 -->
   <!-- Integration Apache Commons Validator by Spring Modules -->		
   <bean id="beanValidator" class="org.springmodules.validation.commons.DefaultBeanValidator">
       <property name="validatorFactory" ref="validatorFactory"/>
   </bean>
   <bean id="validatorFactory" class="org.springmodules.validation.commons.DefaultValidatorFactory">
       <property name="validationConfigLocations">
           <list>
               <!-- 공통기술 -->
               <value>classpath:/validator/validator-rules.xml</value>
               <value>classpath:/validator/**/*.xml</value>  
           </list>
       </property>
   </bean>
   ```
   **validator.jsp**
   ```jsp
   <%@ page language="java" contentType="javascript/x-javascript" %>
   <%@ taglib prefix="validator" uri="http://www.springmodules.org/tags/commons-validator" %>
   <validator:javascript dynamicJavascript="false" staticJavascript="true"/>
   ```
   **controller.java**
   ```java
   @GetMapping("/validator.do")
   public String validator() {
       return "jsp/validator"; // Jakarta common validation 활용 위해
   }
   ```
   **message-common.properties**
   ```properties
   # -- validator errors -- #
   updateItemDto.id=ID는 필수 입력 항목입니다.
   updateItemDto.nickname=닉네임은 필수 입력 항목입니다.
   updateItemDto.password=비밀번호는 필수 입력 항목입니다.~!
   updateItemDto.password.integer=비밀번호는 숫자로 입력해주세요.테스트임!!
   updateItemDto.title=제목은 필수 입력 항목입니다.
   updateItemDto.content=내용은 필수 입력 항목입니다.
   #
   fail.common.msg=에러가 발생했습니다!
   fail.common.sql=sql 에러가 발생했습니다! error code: {0}, error msg: {1}
   info.nodata.msg=해당 데이터가 없습니다.
   errors.prefix=<div class="error"> 
   errors.suffix=</div><br/>
   errors.required={0} 은 필수 입력값입니다.~!~!
   errors.minlength={0} 은 {1}자 이상 입력해야 합니다.
   errors.maxlength={0} 은 {1}자 이상 입력할수 없습니다.
   errors.invalid={0} 은 유효하지 않은 값입니다.
   errors.byte={0} 은 byte 타입이어야 합니다.
   errors.short={0} 은 short 타입이어야 합니다.
   errors.integer={0} 은 integer 타입이어야 합니다.
   errors.long={0} 은 long 타입이어야 합니다.
   errors.float={0} 은 float 타입이어야 합니다.
   errors.double={0} 은 double 타입이어야 합니다.
   errors.date={0} 은 날짜 유형이 아닙니다.
   errors.range={0} 은 {1} 과 {2} 사이의 값이어야 합니다.
   errors.creditcard={0} 은 유효하지 않은 신용카드 번호입니다.
   errors.email={0} 은 유효하지 않은 이메일 주소입니다.
   errors.ihidnum=유효하지 않은 주민등록번호입니다.
   errors.korean={0}은 한글을 입력하셔야 합니다.
   ```
   </div>
   </details>

   <details><summary><b>Bean 방식 vs Jakarta 방식 코드 예시(+JS직접,자동): th:error vs form:errors</b></summary>
   <div markdown="1"><br>
   th:error, form:errors는 유사하다. 오히려 Bean, Jakarta 방식의 다른점을 비교해야 한다.<br>
   "클라단 검증" 과 "메시지 설정" 및 xml설정은 위 정리글 보고,<br>
   **"서버단 검증"을 중점적으로 비교**
   ```java
   /*
   차이점:
   @Validated 유무로 인해 beanValidator.validate(form, bindingResult); 생략 유무
   @Pattern(regexp = "^[0-9]+", message = "비밀번호는 숫자로 입력 해주세요.") 처럼 DTO에 바로 적용 메시지 유무
   */
   //Bean Validation
   @PostMapping("item/{itemId}")
       public String studioIdUpdate(@Validated @ModelAttribute UpdateItemDto form, @RequestParam int pageIndex, BindingResult bindingResult,
                                    @PathVariable Long itemId, RedirectAttributes redirectAttributes, Model model) throws Exception {
           if(bindingResult.hasErrors()) {
               log.info("error={}", bindingResult);
               model.addAttribute("bindingResult", bindingResult); //서버단 Valid결과 알려주는거
               return "jsp/studio_item"; //다시 폼으로 이동
               // 어차피 "검증" 에 걸려서 DB 사용안하기에 PRG 패턴 상관없움
           }
           form.setPageIndex(pageIndex);
           itemService.update(form);
         redirectAttributes.addFlashAttribute("status", "updateON");
         redirectAttributes.addAttribute("itemId", itemId);
         return "redirect:/gallery/itemDetail/{itemId}";   
   //DTO
   @Data
   public class UpdateItemDto {
   	  @NotNull
   	  private Long id;
   	  @NotNull
   	  private String nickname;
   	  @NotNull
   	  @Pattern(regexp = "^[0-9]+", message = "비밀번호는 숫자로 입력 해주세요.")
   	  private String password;
   	  @NotNull
   	  private String title;
   	  @NotNull
   	  private String content;
   	  private int pageIndex;
   }
   //
   //
   //Jakarta Validation
   private final DefaultBeanValidator beanValidator;
   @PostMapping("item/{itemId}")
   public String studioIdUpdate(@ModelAttribute UpdateItemDto form, @RequestParam int pageIndex, BindingResult bindingResult,
                                @PathVariable Long itemId, RedirectAttributes redirectAttributes, Model model) throws Exception {
   	beanValidator.validate(form, bindingResult); //@Validated 사용 안하면 직접 해줘야 함.
   	if(bindingResult.hasErrors()) {
           log.info("error={}", bindingResult);
           model.addAttribute("bindingResult", bindingResult); //서버단 Valid결과 알려주는거 (직접 에러 커스텀도 해가지고 추가했음. form:error만 사용할경우 이 코드 필요없음)
           return this.studioCompleteId(itemId, pageIndex, model); //다시 폼으로 이동 (item/{itemId}로 이동해야해서 내무메소드로 호출하겠음. 애초에 수정폼은 따로 둬서 폼바로 호출해야 했다. 이 방식은 비추다 ㅠ.)
       }
       form.setPageIndex(pageIndex);
       itemService.update(form);
     redirectAttributes.addFlashAttribute("status", "updateON");
     redirectAttributes.addAttribute("itemId", itemId);
     return "redirect:/gallery/itemDetail/{itemId}";  
   }
   //DTO
   @Data
   public class UpdateItemDto {
   	  private Long id;
   	  private String nickname;
   	  private String password;
   	  private String title;
   	  private String content;
   	  private int pageIndex;
   }
   ```
   ```xml
   <!-- form:errors 출력! th:error는 방식 유사하여 생략 -->
   <%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%>
   <form:form action=""
              method="post" modelAttribute="updateItemDto">
   <input type="password" class="no-spin" id="password" name="password" value="${item.password}" ...생략 />
   <form:errors id="password" name="password" path="password" />
   <!-- -->
   <!-- -->
   <!-- 번외로 소개한 bindingResult model에 담아 가져와 직접 커스텀 방식 -->
   <div class="field-error">
   	<%-- <c:if test="${not empty bindingResult.fieldErrors['password']}"> --%>
       <c:if test="${not empty bindingResult.fieldErrors}">
           비밀번호 오류
           <%-- 비밀번호 오류: <c:out value="${bindingResult.fieldErrors}" /> --%>
       </c:if>
   </div>
   ```
   </div>
   </details>

5. 예외처리와 AOP -> xml활용 (연습 삼아!)

   > **API의 경우 클라쪽 "검증"은 서버가 할 일이 아니다(JS는 프론트쪽 개발진이 해야지!)**  
   > **웹의 경우 클라와 서버쪽 둘 다 "검증"**해주는게 좋다.
   >
   > **API의 "예외"**의 경우 서버는 **JSON으로 변경된 데이터를 “Valid(검증)”**하는거라서 **JSON→DTO매핑될 때 에러나 그 시점에 다양한 에러(주로 서비스로직)들은 “Exception(예외)”**으로 해결!
   > **=> 웹은 “검증”만으로 충분하지만 API는 “검증+예외”가 필요!**  
   > => 근데, 막상 해보니 웹&API 둘다 "검증+예외"를 적용 했다. eGov에선 웹에 에러페이지만 연동해주는게 아니라 "예외"까지 굳이 하더라?
   >
   > **예외를 처리하는 방법 크게 2가지**
   >
   > 1. 예외를 잡아서 정상화 하는 방법 ⇒ 예로 try, catch
   >
   > 2. 예외를 해결할 수 없는 문제로 인정하고 공통 처리하는 방법(사용자에게 죄송합니다. 같은 화면을 보여주는 방법) ⇒ 예로 @ExceptionHandler + @ControllerAdvice
   >
   >    특히, API(JSON)의 경우 대부분 2번으로 해결 됨. 직접 예외를 throw로 던져서 공통 관리해도 되니까.
   >
   > 예외를 처리하는 계층의 흐름 이해:
   >
   > 1. 서비스계층의 비즈니스 로직의 예외 발생하면 정상화하거나 공통 처리위해 던지기
   > 2. 컨트롤러에서 웹이면 서비스의 Exception을 JSP 뷰로 매핑, API면 JSON으로 응답

   서비스계층의 예외 처리:

   - eGov에선 서비스계층의 비즈니스 로직 예외처리를 위해 **EgovAbstractServiceImpl** 를 사용하며,  
     EgovBizException 발생 메소드(**processException**) 와 Exception 발생없이 후처리 로그 메소드(**leaveaTrace**)를 제공한다.
     
     - **다국어 지원 메시지, 확장성, 표준화 로직** 때문에 사용!
     
   - **leaveaTrace -> EgovBizException 발생 없이 로그 생성(메시지소스를 사용하는게 특징)**

     - 메소드 원리: traceHandler빈을 참조한 leaveaTrace빈을 xml이나 java로 등록 후 leaveaTrace빈을 주입해 사용하여 핸들링한다.

     - MessageSource 빈에 등록된 메시지를 로그(Info)로 제공

     - <details><summary><b>xml 설정 코드 예시:</b></summary>
       <div markdown="1"><br>
       **context-common.xml (비즈니스단 계층용 설정파일)**
       ```xml
       <!-- EgovAbstractServiceImpl가 제공하는 leaveaTrace(예외처리 관련) 사용 위해 빈 등록 필수! -->
       <bean id="leaveaTrace"
       	class="org.egovframe.rte.fdl.cmmn.trace.LeaveaTrace">
       	<property name="traceHandlerServices">
       		<list>
       			<ref bean="traceHandlerService" />
       		</list>
       	</property>
       </bean>
       <bean id="traceHandlerService"
       	class="org.egovframe.rte.fdl.cmmn.trace.manager.DefaultTraceHandleManager">
       	<property name="reqExpMatcher">
       		<ref bean="antPathMater" />
       	</property>
       	<property name="patterns">
       		<list>
       			<value>*</value>
       		</list>
       	</property>
       	<property name="handlers">
       		<list>
       			<ref bean="defaultTraceHandler" />
       		</list>
       	</property>
       </bean>
       <bean id="antPathMater"
       	class="org.springframework.util.AntPathMatcher" />
       <bean id="defaultTraceHandler"
       	class="org.egovframe.rte.fdl.cmmn.trace.handler.DefaultTraceHandler" />
       ```
       </div>
       </details>

     - **leaveaTrace 메소드 적용 예시:**

     - ```java
       //EgovAbstractServiceImpl를 상속한 서비스로직이라 가정
       try{
           //비즈니스 로직
       }catch {
           //fail.common.msg=에러가 발생했습니다! 라고 message.properties에 있음
           leaveaTrace("fail.common.msg"); 
       }
       ```

   - **processException -> 예외들을 EgovBizException 예외로 바꿈 + 로그 생성(메시지소스를 사용)**

     - 메소드 원리: 발생한 예외를 EgovBizException 로 감싸는 방식

     - MessageSource 빈에 등록된 메시지를 로그(Info)로 제공

     - ```java
       //EgovAbstractServiceImpl를 상속한 서비스로직이라 가정
       try{
           int i = 1/0;
       }catch(ArithmeticException ae){
           throw processException("fail.common.msg");
       }
       ```

   - **예시 결과:**

     <img src="/images/2023-12-02-CHECK_LIST_SPRING/image-20250406231902976.png" alt="image-20250406231902976" style="zoom:80%;" />

   컨트롤러계층(+AOP)의 예외 처리:

   > 웹 플젝 스프링 부트는 ErrorPage, BasicErrorController를 자동등록하여 예외 핸들링 에러페이지 자동
   >
   > API는 부트든 아니든 @ExceptionHandelr + @ControllerAdvice로 예외 공통 관리 및 JSON 응답 젤 편함!

   - 웹 플젝 eGov에서는 부트가 한 **에러페이지** 자동등록 설정을 SimpleMappingExceptionResolver빈 등록으로 직접 하는편. (리졸버뷰를 생각하자)

     - **jsp에도 MessageSource 빈의 메시지가 출력이 됨**.(exception.message로 서버상에서 MessageSource 빈 메시지를 기록해둔다고 예상)

     - <details><summary><b>xml 설정과 error-page(jsp) 코드 예시:</b></summary>
       <div markdown="1"><br>
       **context-servlet.xml (컨트롤러단 계층용 설정파일)**
       ```xml
       <!-- 직접 원하는 Exception과 에러뷰를 매핑 확장 가능 -->
       <bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
           <property name="defaultErrorView" value="jsp/cmmn/genneralException" />
           <property name="exceptionMappings">
               <props>
                   <prop key="org.egovframe.rte.fdl.cmmn.exception.EgovBizException">jsp/cmmn/egovBizException</prop>
                   <prop key="org.springframework.dao.DataAccessException">jsp/cmmn/egovBizException</prop>
                   <prop key="org.springframework.transaction.TransactionException">jsp/cmmn/egovBizException</prop>
               </props>
           </property>
       </bean>
       ```
       **egovBizException.jsp**
       ```jsp
       <%@ page language="java" contentType="text/html; charset=UTF-8" %>
       <html>
       <head>
       <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
       <title>에러가 발생하였습니다.종류는 EgovBizException 입니다.</title>
       </head>
       <body>
       에러가 발생하였습니다.종류는 EgovBizException 입니다. 메세지는${exception.message} 입니다.
       </body>
       </html>
       ```
       ```**genneralException.jsp**
       <%@ page language="java" contentType="text/html; charset=UTF-8" %>
       <html>
       <head>
       <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
       <title>일반적인 에러가 발생하였습니다.</title>
       </head>
       <body>
       일반적인 에러가 발생하였습니다. 메세지는${exception.message} 입니다.
       </body>
       </html>
       ```
       </div>
       </details>

   - @ExceptionHandelr 로 예외 공통 관리하던걸 **"eGov의 ExceptionHandler인터페이스"**를 구현하여 **AOP를 직접 설정**하자. (예시 부분의 콘솔을 봐라)

     - **주의:** "부트"(순수스프링 아님)에선 자동으로 예외처리기를 제공하다보니 아래 AOP적용한 예외처리기와 중복 사용될 수 있다. (로그상에서 예외가 1번더 출력됨을 확인)

     - <details><summary><b>xml 설정과 ExceptionHandler 구현 코드 예시:</b></summary>
       <div markdown="1"><br>
       **ExceptionHandler 구현 코드 java**
       ```java
       @Slf4j
       public class SecretGalleryExceptionHandler implements ExceptionHandler {
           public void occur(Exception exception, String packageName) {
           	log.debug(" EasyCompanyExceptionHandler run...............{}", ((EgovBizException) exception).getWrappedException());
               try {
                   if (exception instanceof EgovBizException) {
                       Exception exx = (Exception) ((EgovBizException) exception).getWrappedException();
                       if (exx != null) {
                       	log.debug(" sending a alert mail  is completed ");
                           exx.printStackTrace();
                       }
                   }
               } catch (Exception e) { //일반 예외
                   e.printStackTrace();
               }
           }
       }
       ```
       **context-aspect.xml**
       ```xml
       <?xml version="1.0" encoding="UTF-8"?>
       <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       	xmlns:aop="http://www.springframework.org/schema/aop"
       	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
       		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd">
       <!-- -->
       	<aop:config>
       		<aop:pointcut id="serviceMethod" expression="execution(* com.secretgallery..impl.*Impl.*(..))" />
       		<aop:aspect ref="exceptionTransfer">
       			<aop:after-throwing throwing="exception" pointcut-ref="serviceMethod" method="transfer" />
       		</aop:aspect>
       	</aop:config>
       <!-- -->
       	<bean id="exceptionTransfer" class="org.egovframe.rte.fdl.cmmn.aspect.ExceptionTransfer">
       		<property name="exceptionHandlerService">
       			<list>
       				<ref bean="defaultExceptionHandleManager" />
       			</list>
       		</property>
       	</bean>
       <!-- -->
       	<bean id="defaultExceptionHandleManager" class="org.egovframe.rte.fdl.cmmn.exception.manager.DefaultExceptionHandleManager">
       		<property name="reqExpMatcher">
       			<ref bean="antPathMater" />
       		</property>
       		<property name="patterns">
       			<list>
       				<value>**service.impl.**</value>
       			</list>
       		</property>
       		<property name="handlers">
       			<list>
       				<ref bean="exceptionHandler" />
       			</list>
       		</property>
       	</bean>
       <!-- -->
       	<bean id="exceptionHandler" class="com.secretgallery.exception.SecretGalleryExceptionHandler" />
       </beans>
       ```
       </div>
       </details>

     - **사용예시 코드:**

       등록한 EasyCompanyExceptionHandler빈을 통해 공통으로 예외처리 관리 가능

       ```java
       //EgovBizException 관련 공통예외처리 로직 수행 (ExceptionHandler 구현로직 참고)
       throw processException("msg.exception.case1", new RuntimeException("실제 원인"));
       //일반 공통예외처리 로직 수행 (ExceptionHandler 구현로직 참고)
       throw new Exception(); 
       ...
       ```

       - 특히, "msg.exception.case1=에러테스트를 위한 에러를 발생시킵니다." 으로 기록된 메시지를 JSP에 출력

   - **전체적 흐름 이해하기:** 

     1. 서비스계층의 leaveaTrace, processException 를 적절히 활용하여 예외 처리하고 싶은부분에 사용(leaveaTrace빈이 잘 동작)

        예외 정상으로? leaveaTrace  
        예외 EgovBizException 으로 바꾸려면? processException   
        예외 일반은? 그냥 원하는 예외로 throw 하거나 그냥 둬도 AOP에서 잘 처리

     2. 컨트롤러,AOP단에서 exceptionTransfer빈이 동작하여 예외를 가로채고 EasyCompanyExceptionHandler빈으로 공통으로 예외처리(보통 콘솔에 메시지 출력)

     3. 컨트롤러,AOP단에서 SimpleMappingExceptionResolver빈이 동작하여 예외일때 리졸버뷰로써 잘 동작

        예외 EgovBizException은? 등록한 egovBizException.jsp 출력  
        예외 DataAccessException은? 등록한 egovBizException.jsp 출력   
        예외 TransactionException은? 등록한 egovBizException.jsp 출력  
        예외 일반은? 등록한 genneralException.jsp 출력

   - **예시 결과:**

     홈페이지

     <img src="/images/2023-12-02-CHECK_LIST_SPRING/image-20250407001802824.png" alt="image-20250407001802824" style="zoom:80%;" />

     콘솔

     <img src="/images/2023-12-02-CHECK_LIST_SPRING/image-20250407001849320.png" alt="image-20250407001849320" style="zoom:80%;" />

   **번외) 메소드 수행시간 측정 AOP는 Java Config로 해보겠다.**

   - <details><summary><b>TimeTraceAop.java 코드 예시:</b></summary>
     <div markdown="1"><br>
     ```java
     @Aspect // AOP
     @Component // "빈" 등록
     @Slf4j
     public class TimeTraceAop {
       @Around("execution(* com.secretgallery..*(..)) && !within(com.secretgallery.security..*)")
       public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {
         // 프록시 실행
         long start = System.currentTimeMillis();
         log.debug("START: {}", joinPoint.toString());
         try {
           return joinPoint.proceed(); // 실제 실행
         } finally {
           long finish = System.currentTimeMillis();
           long timeMs = finish - start;
           log.debug("END: {} {}ms", joinPoint.toString(), timeMs);
         }
       }
     }
     ```
     </div>
     </details>

<br>

egov가이드내용은 따로 md추가하자. (일단 지식카테에 하고, 나중에 md들할때 egov카테로....)

이클립스의 기능에 로그인쪽(게시판 등?) **"공통기능" 이용 + Spring Security(공통기능)**도 표준프레임워크로 [security](https://arckwon.tistory.com/entry/%EC%A0%84%EC%9E%90%EC%A0%95%EB%B6%80%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%8A%A4%ED%94%84%EB%A7%81%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%A0%81%EC%9A%A912), [암호화](https://arckwon.tistory.com/entry/%EC%A0%84%EC%9E%90%EC%A0%95%EB%B6%80%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-DB%EC%A0%91%EC%86%8D%EC%A0%95%EB%B3%B4-%EC%95%94%ED%98%B8%ED%99%94-crypto-%EC%84%9C%EB%B9%84%EC%8A%A4), [공문](https://www.egovframe.go.kr/wiki/doku.php?id=egovframework:rte4.0:fdl:server_security) 참고!  
=> 이것도 어차피 안할거니 언급만 좀.. eGov가이드 정리한거에 공통기능 얘기하면서..

이클립스의 기능에 01.개발환경_교육교재.pdf에 **Jenkins(CI)** 이것도 pdf보고 대충 언급만 좀 하고.. 

Spring Batch도 이미 가이드 정리한거에 얘기하면서 대충 언급만 좀 하고...

<br>

그리고 꼭 꼭ㄲ곡꼭 이시리즈 끝나면 쳌리들이나 쭈~욱 깃블로그에 포스팅해두자. 걍 GPT로 완전 빠르겡ㅇ



